package org.ffmpeg.avfilter;
import org.bridj.BridJ;
import org.bridj.Callback;
import org.bridj.IntValuedEnum;
import org.bridj.Pointer;
import org.bridj.StructObject;
import org.bridj.ann.Field;
import org.bridj.ann.Library;
import org.bridj.ann.Ptr;
import org.ffmpeg.avutil.AVFrame;
import org.ffmpeg.avutil.AvutilLibrary.AVMediaType;
/**
 * A filter pad used for either input or output.<br>
 * * See doc/filter_design.txt for details on how to implement the methods.<br>
 * * @warning this struct might be removed from public API.<br>
 * users should call avfilter_pad_get_name() and avfilter_pad_get_type()<br>
 * to access the name and type fields; there should be no need to access<br>
 * any other fields from outside of libavfilter.<br>
 * <i>native declaration : libavfilter/avfilter.h:311</i><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("avfilter") 
public class AVFilterPad extends StructObject {
	static {
		BridJ.register();
	}
	/**
	 * Pad name. The name is unique among inputs and among outputs, but an<br>
	 * input may have the same name as an output. This may be NULL if this<br>
	 * pad has no need to ever be referenced by name.<br>
	 * C type : const char*
	 */
	@Field(0) 
	public Pointer<Byte > name() {
		return this.io.getPointerField(this, 0);
	}
	/**
	 * Pad name. The name is unique among inputs and among outputs, but an<br>
	 * input may have the same name as an output. This may be NULL if this<br>
	 * pad has no need to ever be referenced by name.<br>
	 * C type : const char*
	 */
	@Field(0) 
	public AVFilterPad name(Pointer<Byte > name) {
		this.io.setPointerField(this, 0, name);
		return this;
	}
	/**
	 * AVFilterPad type.<br>
	 * C type : AVMediaType
	 */
	@Field(1) 
	public IntValuedEnum<AVMediaType > type() {
		return this.io.getEnumField(this, 1);
	}
	/**
	 * AVFilterPad type.<br>
	 * C type : AVMediaType
	 */
	@Field(1) 
	public AVFilterPad type(IntValuedEnum<AVMediaType > type) {
		this.io.setEnumField(this, 1, type);
		return this;
	}
	/**
	 * Input pads:<br>
	 * Minimum required permissions on incoming buffers. Any buffer with<br>
	 * insufficient permissions will be automatically copied by the filter<br>
	 * system to a new buffer which provides the needed access permissions.<br>
	 * * Output pads:<br>
	 * Guaranteed permissions on outgoing buffers. Any buffer pushed on the<br>
	 * link must have at least these permissions; this fact is checked by<br>
	 * asserts. It can be used to optimize buffer allocation.
	 */
	@Field(2) 
	public int min_perms() {
		return this.io.getIntField(this, 2);
	}
	/**
	 * Input pads:<br>
	 * Minimum required permissions on incoming buffers. Any buffer with<br>
	 * insufficient permissions will be automatically copied by the filter<br>
	 * system to a new buffer which provides the needed access permissions.<br>
	 * * Output pads:<br>
	 * Guaranteed permissions on outgoing buffers. Any buffer pushed on the<br>
	 * link must have at least these permissions; this fact is checked by<br>
	 * asserts. It can be used to optimize buffer allocation.
	 */
	@Field(2) 
	public AVFilterPad min_perms(int min_perms) {
		this.io.setIntField(this, 2, min_perms);
		return this;
	}
	/**
	 * Input pads:<br>
	 * Permissions which are not accepted on incoming buffers. Any buffer<br>
	 * which has any of these permissions set will be automatically copied<br>
	 * by the filter system to a new buffer which does not have those<br>
	 * permissions. This can be used to easily disallow buffers with<br>
	 * AV_PERM_REUSE.<br>
	 * * Output pads:<br>
	 * Permissions which are automatically removed on outgoing buffers. It<br>
	 * can be used to optimize buffer allocation.
	 */
	@Field(3) 
	public int rej_perms() {
		return this.io.getIntField(this, 3);
	}
	/**
	 * Input pads:<br>
	 * Permissions which are not accepted on incoming buffers. Any buffer<br>
	 * which has any of these permissions set will be automatically copied<br>
	 * by the filter system to a new buffer which does not have those<br>
	 * permissions. This can be used to easily disallow buffers with<br>
	 * AV_PERM_REUSE.<br>
	 * * Output pads:<br>
	 * Permissions which are automatically removed on outgoing buffers. It<br>
	 * can be used to optimize buffer allocation.
	 */
	@Field(3) 
	public AVFilterPad rej_perms(int rej_perms) {
		this.io.setIntField(this, 3, rej_perms);
		return this;
	}
	/**
	 * @deprecated unused<br>
	 * C type : start_frame_callback*
	 */
	@Field(4) 
	public Pointer<AVFilterPad.start_frame_callback > start_frame() {
		return this.io.getPointerField(this, 4);
	}
	/**
	 * @deprecated unused<br>
	 * C type : start_frame_callback*
	 */
	@Field(4) 
	public AVFilterPad start_frame(Pointer<AVFilterPad.start_frame_callback > start_frame) {
		this.io.setPointerField(this, 4, start_frame);
		return this;
	}
	/**
	 * Callback function to get a video buffer. If NULL, the filter system will<br>
	 * use ff_default_get_video_buffer().<br>
	 * * Input video pads only.<br>
	 * C type : get_video_buffer_callback*
	 */
	@Field(5) 
	public Pointer<AVFilterPad.get_video_buffer_callback > get_video_buffer() {
		return this.io.getPointerField(this, 5);
	}
	/**
	 * Callback function to get a video buffer. If NULL, the filter system will<br>
	 * use ff_default_get_video_buffer().<br>
	 * * Input video pads only.<br>
	 * C type : get_video_buffer_callback*
	 */
	@Field(5) 
	public AVFilterPad get_video_buffer(Pointer<AVFilterPad.get_video_buffer_callback > get_video_buffer) {
		this.io.setPointerField(this, 5, get_video_buffer);
		return this;
	}
	/**
	 * Callback function to get an audio buffer. If NULL, the filter system will<br>
	 * use ff_default_get_audio_buffer().<br>
	 * * Input audio pads only.<br>
	 * C type : get_audio_buffer_callback*
	 */
	@Field(6) 
	public Pointer<AVFilterPad.get_audio_buffer_callback > get_audio_buffer() {
		return this.io.getPointerField(this, 6);
	}
	/**
	 * Callback function to get an audio buffer. If NULL, the filter system will<br>
	 * use ff_default_get_audio_buffer().<br>
	 * * Input audio pads only.<br>
	 * C type : get_audio_buffer_callback*
	 */
	@Field(6) 
	public AVFilterPad get_audio_buffer(Pointer<AVFilterPad.get_audio_buffer_callback > get_audio_buffer) {
		this.io.setPointerField(this, 6, get_audio_buffer);
		return this;
	}
	/**
	 * @deprecated unused<br>
	 * C type : end_frame_callback*
	 */
	@Field(7) 
	public Pointer<AVFilterPad.end_frame_callback > end_frame() {
		return this.io.getPointerField(this, 7);
	}
	/**
	 * @deprecated unused<br>
	 * C type : end_frame_callback*
	 */
	@Field(7) 
	public AVFilterPad end_frame(Pointer<AVFilterPad.end_frame_callback > end_frame) {
		this.io.setPointerField(this, 7, end_frame);
		return this;
	}
	/**
	 * @deprecated unused<br>
	 * C type : draw_slice_callback*
	 */
	@Field(8) 
	public Pointer<AVFilterPad.draw_slice_callback > draw_slice() {
		return this.io.getPointerField(this, 8);
	}
	/**
	 * @deprecated unused<br>
	 * C type : draw_slice_callback*
	 */
	@Field(8) 
	public AVFilterPad draw_slice(Pointer<AVFilterPad.draw_slice_callback > draw_slice) {
		this.io.setPointerField(this, 8, draw_slice);
		return this;
	}
	/**
	 * Filtering callback. This is where a filter receives a frame with<br>
	 * audio/video data and should do its processing.<br>
	 * * Input pads only.<br>
	 * * @return >= 0 on success, a negative AVERROR on error. This function<br>
	 * must ensure that frame is properly unreferenced on error if it<br>
	 * hasn't been passed on to another filter.<br>
	 * C type : filter_frame_callback*
	 */
	@Field(9) 
	public Pointer<AVFilterPad.filter_frame_callback > filter_frame() {
		return this.io.getPointerField(this, 9);
	}
	/**
	 * Filtering callback. This is where a filter receives a frame with<br>
	 * audio/video data and should do its processing.<br>
	 * * Input pads only.<br>
	 * * @return >= 0 on success, a negative AVERROR on error. This function<br>
	 * must ensure that frame is properly unreferenced on error if it<br>
	 * hasn't been passed on to another filter.<br>
	 * C type : filter_frame_callback*
	 */
	@Field(9) 
	public AVFilterPad filter_frame(Pointer<AVFilterPad.filter_frame_callback > filter_frame) {
		this.io.setPointerField(this, 9, filter_frame);
		return this;
	}
	/**
	 * Frame poll callback. This returns the number of immediately available<br>
	 * samples. It should return a positive value if the next request_frame()<br>
	 * is guaranteed to return one frame (with no delay).<br>
	 * * Defaults to just calling the source poll_frame() method.<br>
	 * * Output pads only.<br>
	 * C type : poll_frame_callback*
	 */
	@Field(10) 
	public Pointer<AVFilterPad.poll_frame_callback > poll_frame() {
		return this.io.getPointerField(this, 10);
	}
	/**
	 * Frame poll callback. This returns the number of immediately available<br>
	 * samples. It should return a positive value if the next request_frame()<br>
	 * is guaranteed to return one frame (with no delay).<br>
	 * * Defaults to just calling the source poll_frame() method.<br>
	 * * Output pads only.<br>
	 * C type : poll_frame_callback*
	 */
	@Field(10) 
	public AVFilterPad poll_frame(Pointer<AVFilterPad.poll_frame_callback > poll_frame) {
		this.io.setPointerField(this, 10, poll_frame);
		return this;
	}
	/**
	 * Frame request callback. A call to this should result in at least one<br>
	 * frame being output over the given link. This should return zero on<br>
	 * success, and another value on error.<br>
	 * See ff_request_frame() for the error codes with a specific<br>
	 * meaning.<br>
	 * * Output pads only.<br>
	 * C type : request_frame_callback*
	 */
	@Field(11) 
	public Pointer<AVFilterPad.request_frame_callback > request_frame() {
		return this.io.getPointerField(this, 11);
	}
	/**
	 * Frame request callback. A call to this should result in at least one<br>
	 * frame being output over the given link. This should return zero on<br>
	 * success, and another value on error.<br>
	 * See ff_request_frame() for the error codes with a specific<br>
	 * meaning.<br>
	 * * Output pads only.<br>
	 * C type : request_frame_callback*
	 */
	@Field(11) 
	public AVFilterPad request_frame(Pointer<AVFilterPad.request_frame_callback > request_frame) {
		this.io.setPointerField(this, 11, request_frame);
		return this;
	}
	/**
	 * Link configuration callback.<br>
	 * * For output pads, this should set the following link properties:<br>
	 * video: width, height, sample_aspect_ratio, time_base<br>
	 * audio: sample_rate.<br>
	 * * This should NOT set properties such as format, channel_layout, etc which<br>
	 * are negotiated between filters by the filter system using the<br>
	 * query_formats() callback before this function is called.<br>
	 * * For input pads, this should check the properties of the link, and update<br>
	 * the filter's internal state as necessary.<br>
	 * * For both input and output pads, this should return zero on success,<br>
	 * and another value on error.<br>
	 * C type : config_props_callback*
	 */
	@Field(12) 
	public Pointer<AVFilterPad.config_props_callback > config_props() {
		return this.io.getPointerField(this, 12);
	}
	/**
	 * Link configuration callback.<br>
	 * * For output pads, this should set the following link properties:<br>
	 * video: width, height, sample_aspect_ratio, time_base<br>
	 * audio: sample_rate.<br>
	 * * This should NOT set properties such as format, channel_layout, etc which<br>
	 * are negotiated between filters by the filter system using the<br>
	 * query_formats() callback before this function is called.<br>
	 * * For input pads, this should check the properties of the link, and update<br>
	 * the filter's internal state as necessary.<br>
	 * * For both input and output pads, this should return zero on success,<br>
	 * and another value on error.<br>
	 * C type : config_props_callback*
	 */
	@Field(12) 
	public AVFilterPad config_props(Pointer<AVFilterPad.config_props_callback > config_props) {
		this.io.setPointerField(this, 12, config_props);
		return this;
	}
	/**
	 * The filter expects a fifo to be inserted on its input link,<br>
	 * typically because it has a delay.<br>
	 * * input pads only.
	 */
	@Field(13) 
	public int needs_fifo() {
		return this.io.getIntField(this, 13);
	}
	/**
	 * The filter expects a fifo to be inserted on its input link,<br>
	 * typically because it has a delay.<br>
	 * * input pads only.
	 */
	@Field(13) 
	public AVFilterPad needs_fifo(int needs_fifo) {
		this.io.setIntField(this, 13, needs_fifo);
		return this;
	}
	/**
	 * The filter expects writable frames from its input link,<br>
	 * duplicating data buffers if needed.<br>
	 * * input pads only.
	 */
	@Field(14) 
	public int needs_writable() {
		return this.io.getIntField(this, 14);
	}
	/**
	 * The filter expects writable frames from its input link,<br>
	 * duplicating data buffers if needed.<br>
	 * * input pads only.
	 */
	@Field(14) 
	public AVFilterPad needs_writable(int needs_writable) {
		this.io.setIntField(this, 14, needs_writable);
		return this;
	}
	/** <i>native declaration : libavfilter/avfilter.h:302</i> */
	public static abstract class start_frame_callback extends Callback<start_frame_callback > {
		public int apply(Pointer<AVFilterLink > link, Pointer<AVFilterBufferRef > picref) {
			return apply(Pointer.getPeer(link), Pointer.getPeer(picref));
		}
		public int apply(@Ptr long link, @Ptr long picref) {
			return apply(Pointer.pointerToAddress(link, AVFilterLink.class), Pointer.pointerToAddress(picref, AVFilterBufferRef.class));
		}
	};
	/** <i>native declaration : libavfilter/avfilter.h:303</i> */
	public static abstract class get_video_buffer_callback extends Callback<get_video_buffer_callback > {
		public Pointer<AVFrame > apply(Pointer<AVFilterLink > link, int w, int h) {
			return Pointer.pointerToAddress(apply(Pointer.getPeer(link), w, h), AVFrame.class);
		}
		@Ptr 
		public long apply(@Ptr long link, int w, int h) {
			return Pointer.getPeer(apply(Pointer.pointerToAddress(link, AVFilterLink.class), w, h));
		}
	};
	/** <i>native declaration : libavfilter/avfilter.h:304</i> */
	public static abstract class get_audio_buffer_callback extends Callback<get_audio_buffer_callback > {
		public Pointer<AVFrame > apply(Pointer<AVFilterLink > link, int nb_samples) {
			return Pointer.pointerToAddress(apply(Pointer.getPeer(link), nb_samples), AVFrame.class);
		}
		@Ptr 
		public long apply(@Ptr long link, int nb_samples) {
			return Pointer.getPeer(apply(Pointer.pointerToAddress(link, AVFilterLink.class), nb_samples));
		}
	};
	/** <i>native declaration : libavfilter/avfilter.h:305</i> */
	public static abstract class end_frame_callback extends Callback<end_frame_callback > {
		public int apply(Pointer<AVFilterLink > link) {
			return apply(Pointer.getPeer(link));
		}
		public int apply(@Ptr long link) {
			return apply(Pointer.pointerToAddress(link, AVFilterLink.class));
		}
	};
	/** <i>native declaration : libavfilter/avfilter.h:306</i> */
	public static abstract class draw_slice_callback extends Callback<draw_slice_callback > {
		public int apply(Pointer<AVFilterLink > link, int y, int height, int slice_dir) {
			return apply(Pointer.getPeer(link), y, height, slice_dir);
		}
		public int apply(@Ptr long link, int y, int height, int slice_dir) {
			return apply(Pointer.pointerToAddress(link, AVFilterLink.class), y, height, slice_dir);
		}
	};
	/** <i>native declaration : libavfilter/avfilter.h:307</i> */
	public static abstract class filter_frame_callback extends Callback<filter_frame_callback > {
		public int apply(Pointer<AVFilterLink > link, Pointer<AVFrame > frame) {
			return apply(Pointer.getPeer(link), Pointer.getPeer(frame));
		}
		public int apply(@Ptr long link, @Ptr long frame) {
			return apply(Pointer.pointerToAddress(link, AVFilterLink.class), Pointer.pointerToAddress(frame, AVFrame.class));
		}
	};
	/** <i>native declaration : libavfilter/avfilter.h:308</i> */
	public static abstract class poll_frame_callback extends Callback<poll_frame_callback > {
		public int apply(Pointer<AVFilterLink > link) {
			return apply(Pointer.getPeer(link));
		}
		public int apply(@Ptr long link) {
			return apply(Pointer.pointerToAddress(link, AVFilterLink.class));
		}
	};
	/** <i>native declaration : libavfilter/avfilter.h:309</i> */
	public static abstract class request_frame_callback extends Callback<request_frame_callback > {
		public int apply(Pointer<AVFilterLink > link) {
			return apply(Pointer.getPeer(link));
		}
		public int apply(@Ptr long link) {
			return apply(Pointer.pointerToAddress(link, AVFilterLink.class));
		}
	};
	/** <i>native declaration : libavfilter/avfilter.h:310</i> */
	public static abstract class config_props_callback extends Callback<config_props_callback > {
		public int apply(Pointer<AVFilterLink > link) {
			return apply(Pointer.getPeer(link));
		}
		public int apply(@Ptr long link) {
			return apply(Pointer.pointerToAddress(link, AVFilterLink.class));
		}
	};
	public AVFilterPad() {
		super();
	}
	public AVFilterPad(Pointer pointer) {
		super(pointer);
	}
}
