package org.ffmpeg.avfilter;
import org.bridj.BridJ;
import org.bridj.CRuntime;
import org.bridj.Callback;
import org.bridj.FlagSet;
import org.bridj.IntValuedEnum;
import org.bridj.Pointer;
import org.bridj.ann.Library;
import org.bridj.ann.Ptr;
import org.bridj.ann.Runtime;
import org.bridj.util.DefaultParameterizedType;
import org.ffmpeg.avutil.AVClass;
import org.ffmpeg.avutil.AVDictionary;
import org.ffmpeg.avutil.AVFrame;
import org.ffmpeg.avutil.AVRational;
import org.ffmpeg.avutil.AvutilLibrary.AVMediaType;
import org.ffmpeg.avutil.AvutilLibrary.AVPixelFormat;
import org.ffmpeg.avutil.AvutilLibrary.AVSampleFormat;
/**
 * Wrapper for library <b>avfilter</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("avfilter") 
@Runtime(CRuntime.class) 
public class AvfilterLibrary {
	static {
		BridJ.register();
	}
	/** < all automatic conversions enabled */
	public static final int AVFILTER_AUTO_CONVERT_ALL = 0;
	/** < all automatic conversions disabled */
	public static final int AVFILTER_AUTO_CONVERT_NONE = -1;
	/** Do not check for format changes. */
	public static final int AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT = 1;
	/** Ignored */
	public static final int AV_BUFFERSRC_FLAG_NO_COPY = 2;
	/** Immediately push the frame to the output. */
	public static final int AV_BUFFERSRC_FLAG_PUSH = 4;
	/**
	 * Keep a reference to the frame.<br>
	 * If the frame if reference-counted, create a new reference; otherwise<br>
	 * copy the frame data.
	 */
	public static final int AV_BUFFERSRC_FLAG_KEEP_REF = 8;
	/**
	 * Conversion Error : a.num<br>
	 * SKIPPED:<br>
	 * <i>native declaration : libavutil/rational.h:0</i><br>
	 * const int64_t tmp = a.num * (int64_t)b.den - b.num * (int64_t)a.den;
	 */
	/** <i>native declaration : libavfilter/avfilter.h</i> */
	public static final int AVFILTER_THREAD_SLICE = (int)(1 << 0);
	/** <i>native declaration : ./libavfilter/version.h</i> */
	public static final String LIBAVFILTER_IDENT = (String)"Lavfi5.11.102";
	/** <i>native declaration : libavfilter/avfilter.h</i> */
	public static final int AV_PERM_ALIGN = (int)0x40;
	/** <i>native declaration : ./libavfilter/version.h</i> */
	public static final boolean FF_API_AVFILTERPAD_PUBLIC = (boolean)(5 < 6);
	/** <i>native declaration : libavfilter/avfilter.h</i> */
	public static final int AV_PERM_WRITE = (int)0x02;
	/** <i>native declaration : libavfilter/buffersink.h</i> */
	public static final int AV_BUFFERSINK_FLAG_PEEK = (int)1;
	/** <i>native declaration : ./libavfilter/version.h</i> */
	public static final boolean FF_API_AVFILTER_INIT_FILTER = (boolean)(5 < 6);
	/** <i>native declaration : libavfilter/avfilter.h</i> */
	public static final int AV_PERM_REUSE = (int)0x08;
	/** <i>native declaration : libavfilter/avfilter.h</i> */
	public static final int AVFILTER_FLAG_SUPPORT_TIMELINE = (int)((1 << 16) | (1 << 17));
	/** <i>native declaration : ./libavfilter/version.h</i> */
	public static final int LIBAVFILTER_VERSION_MICRO = (int)102;
	/** <i>native declaration : libavfilter/avfilter.h</i> */
	public static final int AVFILTER_FLAG_DYNAMIC_OUTPUTS = (int)(1 << 1);
	/** <i>native declaration : ./libavfilter/version.h</i> */
	public static final boolean FF_API_AVFILTERBUFFER = (boolean)(5 < 6);
	/** <i>native declaration : libavfilter/avfilter.h</i> */
	public static final int AV_PERM_PRESERVE = (int)0x04;
	/** <i>native declaration : libavfilter/avfilter.h</i> */
	public static final int AVFILTER_CMD_FLAG_FAST = (int)2;
	/** <i>native declaration : ./libavfilter/version.h</i> */
	public static final boolean FF_API_OLD_FILTER_REGISTER = (boolean)(5 < 6);
	/** <i>native declaration : ./libavfilter/version.h</i> */
	public static final boolean FF_API_OLD_GRAPH_PARSE = (boolean)(5 < 5);
	/** <i>native declaration : ./libavfilter/version.h</i> */
	public static final int LIBAVFILTER_VERSION_INT = (int)((5) << 16 | (11) << 8 | (102));
	/** <i>native declaration : libavfilter/avfilter.h</i> */
	public static final int AVFILTER_ALIGN = (int)16;
	/** <i>native declaration : libavfilter/buffersink.h</i> */
	public static final int AV_BUFFERSINK_FLAG_NO_REQUEST = (int)2;
	/** <i>native declaration : ./libavfilter/version.h</i> */
	public static final boolean FF_API_FOO_COUNT = (boolean)(5 < 6);
	/** <i>native declaration : libavfilter/avfilter.h</i> */
	public static final int AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC = (int)(1 << 16);
	/** <i>native declaration : libavfilter/avfilter.h</i> */
	public static final int AVFILTER_FLAG_DYNAMIC_INPUTS = (int)(1 << 0);
	/** <i>native declaration : libavfilter/avfilter.h</i> */
	public static final int AV_PERM_REUSE2 = (int)0x10;
	/** <i>native declaration : libavfilter/avfilter.h</i> */
	public static final int AVFILTER_CMD_FLAG_ONE = (int)1;
	/** <i>native declaration : ./libavfilter/version.h</i> */
	public static final boolean FF_API_AVFILTER_OPEN = (boolean)(5 < 6);
	/** <i>native declaration : ./libavfilter/version.h</i> */
	public static final int LIBAVFILTER_VERSION_MAJOR = (int)5;
	/** <i>native declaration : libavfilter/avfilter.h</i> */
	public static final int AVFILTER_FLAG_SUPPORT_TIMELINE_INTERNAL = (int)(1 << 17);
	/** <i>native declaration : ./libavfilter/version.h</i> */
	public static final boolean FF_API_NOCONST_GET_NAME = (boolean)(5 < 6);
	/**
	 * define<br>
	 * Conversion Error : 5.11.<br>
	 * SKIPPED:<br>
	 * <i>native declaration : ./libavfilter/version.h:0</i><br>
	 * 5.11.
	 */
	/** <i>native declaration : ./libavfilter/version.h</i> */
	public static final boolean FF_API_OLD_FILTER_OPTS = (boolean)(5 < 6);
	/** <i>native declaration : libavfilter/avfilter.h</i> */
	public static final int AVFILTER_FLAG_SLICE_THREADS = (int)(1 << 2);
	/** <i>native declaration : libavfilter/avfilter.h</i> */
	public static final int AV_PERM_NEG_LINESIZES = (int)0x20;
	/** <i>native declaration : ./libavfilter/version.h</i> */
	public static final int LIBAVFILTER_VERSION_MINOR = (int)11;
	/** <i>native declaration : libavfilter/avfilter.h</i> */
	public static final int AV_PERM_READ = (int)0x01;
	/** <i>native declaration : ./libavfilter/version.h</i> */
	public static final int LIBAVFILTER_BUILD = (int)((5) << 16 | (11) << 8 | (102));
	/**
	 * A function pointer passed to the @ref AVFilterGraph.execute callback to be<br>
	 * executed multiple times, possibly in parallel.<br>
	 * * @param ctx the filter context the job belongs to<br>
	 * @param arg an opaque parameter passed through from @ref<br>
	 *            AVFilterGraph.execute<br>
	 * @param jobnr the index of the job being executed<br>
	 * @param nb_jobs the total number of jobs<br>
	 * * @return 0 on success, a negative AVERROR on error<br>
	 * <i>native declaration : libavfilter/avfilter.h:878</i>
	 */
	public static abstract class avfilter_action_func extends Callback<avfilter_action_func > {
		public int apply(Pointer<AVFilterContext > ctx, Pointer<? > arg, int jobnr, int nb_jobs) {
			return apply(Pointer.getPeer(ctx), Pointer.getPeer(arg), jobnr, nb_jobs);
		}
		public int apply(@Ptr long ctx, @Ptr long arg, int jobnr, int nb_jobs) {
			return apply(Pointer.pointerToAddress(ctx, AVFilterContext.class), Pointer.pointerToAddress(arg), jobnr, nb_jobs);
		}
	};
	/**
	 * A function executing multiple jobs, possibly in parallel.<br>
	 * * @param ctx the filter context to which the jobs belong<br>
	 * @param func the function to be called multiple times<br>
	 * @param arg the argument to be passed to func<br>
	 * @param ret a nb_jobs-sized array to be filled with return values from each<br>
	 *            invocation of func<br>
	 * @param nb_jobs the number of jobs to execute<br>
	 * * @return 0 on success, a negative AVERROR on error<br>
	 * <i>native declaration : libavfilter/avfilter.h:889</i>
	 */
	public static abstract class avfilter_execute_func extends Callback<avfilter_execute_func > {
		public int apply(Pointer<AVFilterContext > ctx, Pointer<AvfilterLibrary.avfilter_action_func > func, Pointer<? > arg, Pointer<Integer > ret, int nb_jobs) {
			return apply(Pointer.getPeer(ctx), Pointer.getPeer(func), Pointer.getPeer(arg), Pointer.getPeer(ret), nb_jobs);
		}
		public int apply(@Ptr long ctx, @Ptr long func, @Ptr long arg, @Ptr long ret, int nb_jobs) {
			return apply(Pointer.pointerToAddress(ctx, AVFilterContext.class), Pointer.pointerToAddress(func, AvfilterLibrary.avfilter_action_func.class), Pointer.pointerToAddress(arg), Pointer.pointerToAddress(ret, Integer.class), nb_jobs);
		}
	};
	/**
	 * Return the LIBAVFILTER_VERSION_INT constant.<br>
	 * Original signature : <code>int avfilter_version()</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:4</i>
	 */
	public static native int avfilter_version();
	/**
	 * Return the libavfilter build-time configuration.<br>
	 * Original signature : <code>char* avfilter_configuration()</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:9</i>
	 */
	public static Pointer<Byte > avfilter_configuration() {
		return Pointer.pointerToAddress(avfilter_configuration$2(), Byte.class);
	}
	@Ptr 
	protected native static long avfilter_configuration$2();
	/**
	 * Return the libavfilter license.<br>
	 * Original signature : <code>char* avfilter_license()</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:14</i>
	 */
	public static Pointer<Byte > avfilter_license() {
		return Pointer.pointerToAddress(avfilter_license$2(), Byte.class);
	}
	@Ptr 
	protected native static long avfilter_license$2();
	/**
	 * Copy properties of src to dst, without copying the actual data<br>
	 * Original signature : <code>void avfilter_copy_buffer_ref_props(AVFilterBufferRef*, const AVFilterBufferRef*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:157</i>
	 */
	public static void avfilter_copy_buffer_ref_props(Pointer<AVFilterBufferRef > dst, Pointer<AVFilterBufferRef > src) {
		avfilter_copy_buffer_ref_props(Pointer.getPeer(dst), Pointer.getPeer(src));
	}
	protected native static void avfilter_copy_buffer_ref_props(@Ptr long dst, @Ptr long src);
	/**
	 * Add a new reference to a buffer.<br>
	 * * @param ref   an existing reference to the buffer<br>
	 * @param pmask a bitmask containing the allowable permissions in the new<br>
	 *              reference<br>
	 * @return      a new reference to the buffer with the same properties as the<br>
	 *              old, excluding any permissions denied by pmask<br>
	 * Original signature : <code>AVFilterBufferRef* avfilter_ref_buffer(AVFilterBufferRef*, int)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:167</i>
	 */
	public static Pointer<AVFilterBufferRef > avfilter_ref_buffer(Pointer<AVFilterBufferRef > ref, int pmask) {
		return Pointer.pointerToAddress(avfilter_ref_buffer(Pointer.getPeer(ref), pmask), AVFilterBufferRef.class);
	}
	@Ptr 
	protected native static long avfilter_ref_buffer(@Ptr long ref, int pmask);
	/**
	 * Remove a reference to a buffer. If this is the last reference to the<br>
	 * buffer, the buffer itself is also automatically freed.<br>
	 * * @param ref reference to the buffer, may be NULL<br>
	 * * @note it is recommended to use avfilter_unref_bufferp() instead of this<br>
	 * function<br>
	 * Original signature : <code>void avfilter_unref_buffer(AVFilterBufferRef*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:176</i>
	 */
	public static void avfilter_unref_buffer(Pointer<AVFilterBufferRef > ref) {
		avfilter_unref_buffer(Pointer.getPeer(ref));
	}
	protected native static void avfilter_unref_buffer(@Ptr long ref);
	/**
	 * Remove a reference to a buffer and set the pointer to NULL.<br>
	 * If this is the last reference to the buffer, the buffer itself<br>
	 * is also automatically freed.<br>
	 * * @param ref pointer to the buffer reference<br>
	 * Original signature : <code>void avfilter_unref_bufferp(AVFilterBufferRef**)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:184</i>
	 */
	public static void avfilter_unref_bufferp(Pointer<Pointer<AVFilterBufferRef > > ref) {
		avfilter_unref_bufferp(Pointer.getPeer(ref));
	}
	protected native static void avfilter_unref_bufferp(@Ptr long ref);
	/**
	 * Get the number of channels of a buffer reference.<br>
	 * Original signature : <code>int avfilter_ref_get_channels(AVFilterBufferRef*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:189</i>
	 */
	public static int avfilter_ref_get_channels(Pointer<AVFilterBufferRef > ref) {
		return avfilter_ref_get_channels(Pointer.getPeer(ref));
	}
	protected native static int avfilter_ref_get_channels(@Ptr long ref);
	/**
	 * Get the number of elements in a NULL-terminated array of AVFilterPads (e.g.<br>
	 * AVFilter.inputs/outputs).<br>
	 * Original signature : <code>int avfilter_pad_count(const AVFilterPad*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:317</i>
	 */
	public static int avfilter_pad_count(Pointer<AVFilterPad > pads) {
		return avfilter_pad_count(Pointer.getPeer(pads));
	}
	protected native static int avfilter_pad_count(@Ptr long pads);
	/**
	 * Get the name of an AVFilterPad.<br>
	 * * @param pads an array of AVFilterPads<br>
	 * @param pad_idx index of the pad in the array it; is the caller's<br>
	 *                responsibility to ensure the index is valid<br>
	 * * @return name of the pad_idx'th pad in pads<br>
	 * Original signature : <code>char* avfilter_pad_get_name(const AVFilterPad*, int)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:326</i>
	 */
	public static Pointer<Byte > avfilter_pad_get_name(Pointer<AVFilterPad > pads, int pad_idx) {
		return Pointer.pointerToAddress(avfilter_pad_get_name(Pointer.getPeer(pads), pad_idx), Byte.class);
	}
	@Ptr 
	protected native static long avfilter_pad_get_name(@Ptr long pads, int pad_idx);
	/**
	 * Get the type of an AVFilterPad.<br>
	 * * @param pads an array of AVFilterPads<br>
	 * @param pad_idx index of the pad in the array; it is the caller's<br>
	 *                responsibility to ensure the index is valid<br>
	 * * @return type of the pad_idx'th pad in pads<br>
	 * Original signature : <code>AVMediaType avfilter_pad_get_type(const AVFilterPad*, int)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:335</i>
	 */
	public static IntValuedEnum<AVMediaType > avfilter_pad_get_type(Pointer<AVFilterPad > pads, int pad_idx) {
		return FlagSet.fromValue(avfilter_pad_get_type(Pointer.getPeer(pads), pad_idx), AVMediaType.class);
	}
	protected native static int avfilter_pad_get_type(@Ptr long pads, int pad_idx);
	/**
	 * Link two filters together.<br>
	 * * @param src    the source filter<br>
	 * @param srcpad index of the output pad on the source filter<br>
	 * @param dst    the destination filter<br>
	 * @param dstpad index of the input pad on the destination filter<br>
	 * @return       zero on success<br>
	 * Original signature : <code>int avfilter_link(AVFilterContext*, unsigned, AVFilterContext*, unsigned)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:669</i>
	 */
	public static int avfilter_link(Pointer<AVFilterContext > src, int srcpad, Pointer<AVFilterContext > dst, int dstpad) {
		return avfilter_link(Pointer.getPeer(src), srcpad, Pointer.getPeer(dst), dstpad);
	}
	protected native static int avfilter_link(@Ptr long src, int srcpad, @Ptr long dst, int dstpad);
	/**
	 * Free the link in *link, and set its pointer to NULL.<br>
	 * Original signature : <code>void avfilter_link_free(AVFilterLink**)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:674</i>
	 */
	public static void avfilter_link_free(Pointer<Pointer<AVFilterLink > > link) {
		avfilter_link_free(Pointer.getPeer(link));
	}
	protected native static void avfilter_link_free(@Ptr long link);
	/**
	 * Get the number of channels of a link.<br>
	 * Original signature : <code>int avfilter_link_get_channels(AVFilterLink*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:679</i>
	 */
	public static int avfilter_link_get_channels(Pointer<AVFilterLink > link) {
		return avfilter_link_get_channels(Pointer.getPeer(link));
	}
	protected native static int avfilter_link_get_channels(@Ptr long link);
	/**
	 * Set the closed field of a link.<br>
	 * Original signature : <code>void avfilter_link_set_closed(AVFilterLink*, int)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:684</i>
	 */
	public static void avfilter_link_set_closed(Pointer<AVFilterLink > link, int closed) {
		avfilter_link_set_closed(Pointer.getPeer(link), closed);
	}
	protected native static void avfilter_link_set_closed(@Ptr long link, int closed);
	/**
	 * Negotiate the media format, dimensions, etc of all inputs to a filter.<br>
	 * * @param filter the filter to negotiate the properties for its inputs<br>
	 * @return       zero on successful negotiation<br>
	 * Original signature : <code>int avfilter_config_links(AVFilterContext*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:691</i>
	 */
	public static int avfilter_config_links(Pointer<AVFilterContext > filter) {
		return avfilter_config_links(Pointer.getPeer(filter));
	}
	protected native static int avfilter_config_links(@Ptr long filter);
	/**
	 * Create a buffer reference wrapped around an already allocated image<br>
	 * buffer.<br>
	 * * @param data pointers to the planes of the image to reference<br>
	 * @param linesize linesizes for the planes of the image to reference<br>
	 * @param perms the required access permissions<br>
	 * @param w the width of the image specified by the data and linesize arrays<br>
	 * @param h the height of the image specified by the data and linesize arrays<br>
	 * @param format the pixel format of the image specified by the data and linesize arrays<br>
	 * Original signature : <code>AVFilterBufferRef* avfilter_get_video_buffer_ref_from_arrays(const uint8_t*[4], const int[4], int, int, int, AVPixelFormat)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:703</i>
	 */
	public static Pointer<AVFilterBufferRef > avfilter_get_video_buffer_ref_from_arrays(Pointer<Pointer<Byte > > data, Pointer<Integer > linesize, int perms, int w, int h, IntValuedEnum<AVPixelFormat > format) {
		return Pointer.pointerToAddress(avfilter_get_video_buffer_ref_from_arrays(Pointer.getPeer(data), Pointer.getPeer(linesize), perms, w, h, (int)format.value()), AVFilterBufferRef.class);
	}
	@Ptr 
	protected native static long avfilter_get_video_buffer_ref_from_arrays(@Ptr long data, @Ptr long linesize, int perms, int w, int h, int format);
	/**
	 * Create an audio buffer reference wrapped around an already<br>
	 * allocated samples buffer.<br>
	 * * See avfilter_get_audio_buffer_ref_from_arrays_channels() for a version<br>
	 * that can handle unknown channel layouts.<br>
	 * * @param data           pointers to the samples plane buffers<br>
	 * @param linesize       linesize for the samples plane buffers<br>
	 * @param perms          the required access permissions<br>
	 * @param nb_samples     number of samples per channel<br>
	 * @param sample_fmt     the format of each sample in the buffer to allocate<br>
	 * @param channel_layout the channel layout of the buffer<br>
	 * Original signature : <code>AVFilterBufferRef* avfilter_get_audio_buffer_ref_from_arrays(uint8_t**, int, int, int, AVSampleFormat, uint64_t)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:717</i>
	 */
	public static Pointer<AVFilterBufferRef > avfilter_get_audio_buffer_ref_from_arrays(Pointer<Pointer<Byte > > data, int linesize, int perms, int nb_samples, IntValuedEnum<AVSampleFormat > sample_fmt, long channel_layout) {
		return Pointer.pointerToAddress(avfilter_get_audio_buffer_ref_from_arrays(Pointer.getPeer(data), linesize, perms, nb_samples, (int)sample_fmt.value(), channel_layout), AVFilterBufferRef.class);
	}
	@Ptr 
	protected native static long avfilter_get_audio_buffer_ref_from_arrays(@Ptr long data, int linesize, int perms, int nb_samples, int sample_fmt, long channel_layout);
	/**
	 * Create an audio buffer reference wrapped around an already<br>
	 * allocated samples buffer.<br>
	 * * @param data           pointers to the samples plane buffers<br>
	 * @param linesize       linesize for the samples plane buffers<br>
	 * @param perms          the required access permissions<br>
	 * @param nb_samples     number of samples per channel<br>
	 * @param sample_fmt     the format of each sample in the buffer to allocate<br>
	 * @param channels       the number of channels of the buffer<br>
	 * @param channel_layout the channel layout of the buffer,<br>
	 *                       must be either 0 or consistent with channels<br>
	 * Original signature : <code>AVFilterBufferRef* avfilter_get_audio_buffer_ref_from_arrays_channels(uint8_t**, int, int, int, AVSampleFormat, int, uint64_t)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:731</i>
	 */
	public static Pointer<AVFilterBufferRef > avfilter_get_audio_buffer_ref_from_arrays_channels(Pointer<Pointer<Byte > > data, int linesize, int perms, int nb_samples, IntValuedEnum<AVSampleFormat > sample_fmt, int channels, long channel_layout) {
		return Pointer.pointerToAddress(avfilter_get_audio_buffer_ref_from_arrays_channels(Pointer.getPeer(data), linesize, perms, nb_samples, (int)sample_fmt.value(), channels, channel_layout), AVFilterBufferRef.class);
	}
	@Ptr 
	protected native static long avfilter_get_audio_buffer_ref_from_arrays_channels(@Ptr long data, int linesize, int perms, int nb_samples, int sample_fmt, int channels, long channel_layout);
	/**
	 * Make the filter instance process a command.<br>
	 * It is recommended to use avfilter_graph_send_command().<br>
	 * Original signature : <code>int avfilter_process_command(AVFilterContext*, const char*, const char*, char*, int, int)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:737</i>
	 */
	public static int avfilter_process_command(Pointer<AVFilterContext > filter, Pointer<Byte > cmd, Pointer<Byte > arg, Pointer<Byte > res, int res_len, int flags) {
		return avfilter_process_command(Pointer.getPeer(filter), Pointer.getPeer(cmd), Pointer.getPeer(arg), Pointer.getPeer(res), res_len, flags);
	}
	protected native static int avfilter_process_command(@Ptr long filter, @Ptr long cmd, @Ptr long arg, @Ptr long res, int res_len, int flags);
	/**
	 * Initialize the filter system. Register all builtin filters.<br>
	 * Original signature : <code>void avfilter_register_all()</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:742</i>
	 */
	public static native void avfilter_register_all();
	/**
	 * Uninitialize the filter system. Unregister all filters.<br>
	 * Original signature : <code>void avfilter_uninit()</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:747</i>
	 */
	public static native void avfilter_uninit();
	/**
	 * Register a filter. This is only needed if you plan to use<br>
	 * avfilter_get_by_name later to lookup the AVFilter structure by name. A<br>
	 * filter can still by instantiated with avfilter_graph_alloc_filter even if it<br>
	 * is not registered.<br>
	 * * @param filter the filter to register<br>
	 * @return 0 if the registration was successful, a negative value<br>
	 * otherwise<br>
	 * Original signature : <code>int avfilter_register(AVFilter*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:758</i>
	 */
	public static int avfilter_register(Pointer<AVFilter > filter) {
		return avfilter_register(Pointer.getPeer(filter));
	}
	protected native static int avfilter_register(@Ptr long filter);
	/**
	 * Original signature : <code>AVFilter* avfilter_get_by_name(const char*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:760</i>
	 */
	public static Pointer<AVFilter > avfilter_get_by_name(Pointer<Byte > name) {
		return Pointer.pointerToAddress(avfilter_get_by_name(Pointer.getPeer(name)), AVFilter.class);
	}
	@Ptr 
	protected native static long avfilter_get_by_name(@Ptr long name);
	/**
	 * Iterate over all registered filters.<br>
	 * @return If prev is non-NULL, next registered filter after prev or NULL if<br>
	 * prev is the last filter. If prev is NULL, return the first registered filter.<br>
	 * Original signature : <code>AVFilter* avfilter_next(const AVFilter*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:767</i>
	 */
	public static Pointer<AVFilter > avfilter_next(Pointer<AVFilter > prev) {
		return Pointer.pointerToAddress(avfilter_next(Pointer.getPeer(prev)), AVFilter.class);
	}
	@Ptr 
	protected native static long avfilter_next(@Ptr long prev);
	/**
	 * If filter is NULL, returns a pointer to the first registered filter pointer,<br>
	 * if filter is non-NULL, returns the next pointer after filter.<br>
	 * If the returned pointer points to NULL, the last registered filter<br>
	 * was already reached.<br>
	 * @deprecated use avfilter_next()<br>
	 * Original signature : <code>AVFilter** av_filter_next(AVFilter**)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:776</i>
	 */
	public static Pointer<Pointer<AVFilter > > av_filter_next(Pointer<Pointer<AVFilter > > filter) {
		return Pointer.pointerToAddress(av_filter_next(Pointer.getPeer(filter)), DefaultParameterizedType.paramType(Pointer.class, AVFilter.class));
	}
	@Ptr 
	protected native static long av_filter_next(@Ptr long filter);
	/**
	 * Create a filter instance.<br>
	 * * @param filter_ctx put here a pointer to the created filter context<br>
	 * on success, NULL on failure<br>
	 * @param filter    the filter to create an instance of<br>
	 * @param inst_name Name to give to the new instance. Can be NULL for none.<br>
	 * @return >= 0 in case of success, a negative error code otherwise<br>
	 * @deprecated use avfilter_graph_alloc_filter() instead<br>
	 * Original signature : <code>int avfilter_open(AVFilterContext**, AVFilter*, const char*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:787</i>
	 */
	public static int avfilter_open(Pointer<Pointer<AVFilterContext > > filter_ctx, Pointer<AVFilter > filter, Pointer<Byte > inst_name) {
		return avfilter_open(Pointer.getPeer(filter_ctx), Pointer.getPeer(filter), Pointer.getPeer(inst_name));
	}
	protected native static int avfilter_open(@Ptr long filter_ctx, @Ptr long filter, @Ptr long inst_name);
	/**
	 * Initialize a filter.<br>
	 * * @param filter the filter to initialize<br>
	 * @param args   A string of parameters to use when initializing the filter.<br>
	 *               The format and meaning of this string varies by filter.<br>
	 * @param opaque Any extra non-string data needed by the filter. The meaning<br>
	 *               of this parameter varies by filter.<br>
	 * @return       zero on success<br>
	 * Original signature : <code>int avfilter_init_filter(AVFilterContext*, const char*, void*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:798</i>
	 */
	public static int avfilter_init_filter(Pointer<AVFilterContext > filter, Pointer<Byte > args, Pointer<? > opaque) {
		return avfilter_init_filter(Pointer.getPeer(filter), Pointer.getPeer(args), Pointer.getPeer(opaque));
	}
	protected native static int avfilter_init_filter(@Ptr long filter, @Ptr long args, @Ptr long opaque);
	/**
	 * Initialize a filter with the supplied parameters.<br>
	 * * @param ctx  uninitialized filter context to initialize<br>
	 * @param args Options to initialize the filter with. This must be a<br>
	 *             ':'-separated list of options in the 'key=value' form.<br>
	 *             May be NULL if the options have been set directly using the<br>
	 *             AVOptions API or there are no options that need to be set.<br>
	 * @return 0 on success, a negative AVERROR on failure<br>
	 * Original signature : <code>int avfilter_init_str(AVFilterContext*, const char*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:809</i>
	 */
	public static int avfilter_init_str(Pointer<AVFilterContext > ctx, Pointer<Byte > args) {
		return avfilter_init_str(Pointer.getPeer(ctx), Pointer.getPeer(args));
	}
	protected native static int avfilter_init_str(@Ptr long ctx, @Ptr long args);
	/**
	 * Initialize a filter with the supplied dictionary of options.<br>
	 * * @param ctx     uninitialized filter context to initialize<br>
	 * @param options An AVDictionary filled with options for this filter. On<br>
	 *                return this parameter will be destroyed and replaced with<br>
	 *                a dict containing options that were not found. This dictionary<br>
	 *                must be freed by the caller.<br>
	 *                May be NULL, then this function is equivalent to<br>
	 *                avfilter_init_str() with the second parameter set to NULL.<br>
	 * @return 0 on success, a negative AVERROR on failure<br>
	 * * @note This function and avfilter_init_str() do essentially the same thing,<br>
	 * the difference is in manner in which the options are passed. It is up to the<br>
	 * calling code to choose whichever is more preferable. The two functions also<br>
	 * behave differently when some of the provided options are not declared as<br>
	 * supported by the filter. In such a case, avfilter_init_str() will fail, but<br>
	 * this function will leave those extra options in the options AVDictionary and<br>
	 * continue as usual.<br>
	 * Original signature : <code>int avfilter_init_dict(AVFilterContext*, AVDictionary**)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:829</i>
	 */
	public static int avfilter_init_dict(Pointer<AVFilterContext > ctx, Pointer<Pointer<AVDictionary > > options) {
		return avfilter_init_dict(Pointer.getPeer(ctx), Pointer.getPeer(options));
	}
	protected native static int avfilter_init_dict(@Ptr long ctx, @Ptr long options);
	/**
	 * Free a filter context. This will also remove the filter from its<br>
	 * filtergraph's list of filters.<br>
	 * * @param filter the filter to free<br>
	 * Original signature : <code>void avfilter_free(AVFilterContext*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:836</i>
	 */
	public static void avfilter_free(Pointer<AVFilterContext > filter) {
		avfilter_free(Pointer.getPeer(filter));
	}
	protected native static void avfilter_free(@Ptr long filter);
	/**
	 * Insert a filter in the middle of an existing link.<br>
	 * * @param link the link into which the filter should be inserted<br>
	 * @param filt the filter to be inserted<br>
	 * @param filt_srcpad_idx the input pad on the filter to connect<br>
	 * @param filt_dstpad_idx the output pad on the filter to connect<br>
	 * @return     zero on success<br>
	 * Original signature : <code>int avfilter_insert_filter(AVFilterLink*, AVFilterContext*, unsigned, unsigned)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:846</i>
	 */
	public static int avfilter_insert_filter(Pointer<AVFilterLink > link, Pointer<AVFilterContext > filt, int filt_srcpad_idx, int filt_dstpad_idx) {
		return avfilter_insert_filter(Pointer.getPeer(link), Pointer.getPeer(filt), filt_srcpad_idx, filt_dstpad_idx);
	}
	protected native static int avfilter_insert_filter(@Ptr long link, @Ptr long filt, int filt_srcpad_idx, int filt_dstpad_idx);
	/**
	 * Copy the frame properties of src to dst, without copying the actual<br>
	 * image data.<br>
	 * * @return 0 on success, a negative number on error.<br>
	 * Original signature : <code>int avfilter_copy_frame_props(AVFilterBufferRef*, const AVFrame*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:853</i>
	 */
	public static int avfilter_copy_frame_props(Pointer<AVFilterBufferRef > dst, Pointer<AVFrame > src) {
		return avfilter_copy_frame_props(Pointer.getPeer(dst), Pointer.getPeer(src));
	}
	protected native static int avfilter_copy_frame_props(@Ptr long dst, @Ptr long src);
	/**
	 * Copy the frame properties and data pointers of src to dst, without copying<br>
	 * the actual data.<br>
	 * * @return 0 on success, a negative number on error.<br>
	 * Original signature : <code>int avfilter_copy_buf_props(AVFrame*, const AVFilterBufferRef*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:860</i>
	 */
	public static int avfilter_copy_buf_props(Pointer<AVFrame > dst, Pointer<AVFilterBufferRef > src) {
		return avfilter_copy_buf_props(Pointer.getPeer(dst), Pointer.getPeer(src));
	}
	protected native static int avfilter_copy_buf_props(@Ptr long dst, @Ptr long src);
	/**
	 * @return AVClass for AVFilterContext.<br>
	 * * @see av_opt_find().<br>
	 * Original signature : <code>AVClass* avfilter_get_class()</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:866</i>
	 */
	public static Pointer<AVClass > avfilter_get_class() {
		return Pointer.pointerToAddress(avfilter_get_class$2(), AVClass.class);
	}
	@Ptr 
	protected native static long avfilter_get_class$2();
	/**
	 * Allocate a filter graph.<br>
	 * Original signature : <code>AVFilterGraph* avfilter_graph_alloc()</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:945</i>
	 */
	public static Pointer<AVFilterGraph > avfilter_graph_alloc() {
		return Pointer.pointerToAddress(avfilter_graph_alloc$2(), AVFilterGraph.class);
	}
	@Ptr 
	protected native static long avfilter_graph_alloc$2();
	/**
	 * Create a new filter instance in a filter graph.<br>
	 * * @param graph graph in which the new filter will be used<br>
	 * @param filter the filter to create an instance of<br>
	 * @param name Name to give to the new instance (will be copied to<br>
	 *             AVFilterContext.name). This may be used by the caller to identify<br>
	 *             different filters, libavfilter itself assigns no semantics to<br>
	 *             this parameter. May be NULL.<br>
	 * * @return the context of the newly created filter instance (note that it is<br>
	 *         also retrievable directly through AVFilterGraph.filters or with<br>
	 *         avfilter_graph_get_filter()) on success or NULL on failure.<br>
	 * Original signature : <code>AVFilterContext* avfilter_graph_alloc_filter(AVFilterGraph*, const AVFilter*, const char*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:959</i>
	 */
	public static Pointer<AVFilterContext > avfilter_graph_alloc_filter(Pointer<AVFilterGraph > graph, Pointer<AVFilter > filter, Pointer<Byte > name) {
		return Pointer.pointerToAddress(avfilter_graph_alloc_filter(Pointer.getPeer(graph), Pointer.getPeer(filter), Pointer.getPeer(name)), AVFilterContext.class);
	}
	@Ptr 
	protected native static long avfilter_graph_alloc_filter(@Ptr long graph, @Ptr long filter, @Ptr long name);
	/**
	 * Get a filter instance identified by instance name from graph.<br>
	 * * @param graph filter graph to search through.<br>
	 * @param name filter instance name (should be unique in the graph).<br>
	 * @return the pointer to the found filter instance or NULL if it<br>
	 * cannot be found.<br>
	 * Original signature : <code>AVFilterContext* avfilter_graph_get_filter(AVFilterGraph*, const char*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:968</i>
	 */
	public static Pointer<AVFilterContext > avfilter_graph_get_filter(Pointer<AVFilterGraph > graph, Pointer<Byte > name) {
		return Pointer.pointerToAddress(avfilter_graph_get_filter(Pointer.getPeer(graph), Pointer.getPeer(name)), AVFilterContext.class);
	}
	@Ptr 
	protected native static long avfilter_graph_get_filter(@Ptr long graph, @Ptr long name);
	/**
	 * Add an existing filter instance to a filter graph.<br>
	 * * @param graphctx  the filter graph<br>
	 * @param filter the filter to be added<br>
	 * * @deprecated use avfilter_graph_alloc_filter() to allocate a filter in a<br>
	 * filter graph<br>
	 * Original signature : <code>int avfilter_graph_add_filter(AVFilterGraph*, AVFilterContext*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:977</i>
	 */
	public static int avfilter_graph_add_filter(Pointer<AVFilterGraph > graphctx, Pointer<AVFilterContext > filter) {
		return avfilter_graph_add_filter(Pointer.getPeer(graphctx), Pointer.getPeer(filter));
	}
	protected native static int avfilter_graph_add_filter(@Ptr long graphctx, @Ptr long filter);
	/**
	 * Create and add a filter instance into an existing graph.<br>
	 * The filter instance is created from the filter filt and inited<br>
	 * with the parameters args and opaque.<br>
	 * * In case of success put in *filt_ctx the pointer to the created<br>
	 * filter instance, otherwise set *filt_ctx to NULL.<br>
	 * * @param name the instance name to give to the created filter instance<br>
	 * @param graph_ctx the filter graph<br>
	 * @return a negative AVERROR error code in case of failure, a non<br>
	 * negative value otherwise<br>
	 * Original signature : <code>int avfilter_graph_create_filter(AVFilterContext**, const AVFilter*, const char*, const char*, void*, AVFilterGraph*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:990</i>
	 */
	public static int avfilter_graph_create_filter(Pointer<Pointer<AVFilterContext > > filt_ctx, Pointer<AVFilter > filt, Pointer<Byte > name, Pointer<Byte > args, Pointer<? > opaque, Pointer<AVFilterGraph > graph_ctx) {
		return avfilter_graph_create_filter(Pointer.getPeer(filt_ctx), Pointer.getPeer(filt), Pointer.getPeer(name), Pointer.getPeer(args), Pointer.getPeer(opaque), Pointer.getPeer(graph_ctx));
	}
	protected native static int avfilter_graph_create_filter(@Ptr long filt_ctx, @Ptr long filt, @Ptr long name, @Ptr long args, @Ptr long opaque, @Ptr long graph_ctx);
	/**
	 * Enable or disable automatic format conversion inside the graph.<br>
	 * * Note that format conversion can still happen inside explicitly inserted<br>
	 * scale and aresample filters.<br>
	 * * @param flags  any of the AVFILTER_AUTO_CONVERT_* constants<br>
	 * Original signature : <code>void avfilter_graph_set_auto_convert(AVFilterGraph*, unsigned)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:998</i>
	 */
	public static void avfilter_graph_set_auto_convert(Pointer<AVFilterGraph > graph, int flags) {
		avfilter_graph_set_auto_convert(Pointer.getPeer(graph), flags);
	}
	protected native static void avfilter_graph_set_auto_convert(@Ptr long graph, int flags);
	/**
	 * Check validity and configure all the links and formats in the graph.<br>
	 * * @param graphctx the filter graph<br>
	 * @param log_ctx context used for logging<br>
	 * @return >= 0 in case of success, a negative AVERROR code otherwise<br>
	 * Original signature : <code>int avfilter_graph_config(AVFilterGraph*, void*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:1010</i>
	 */
	public static int avfilter_graph_config(Pointer<AVFilterGraph > graphctx, Pointer<? > log_ctx) {
		return avfilter_graph_config(Pointer.getPeer(graphctx), Pointer.getPeer(log_ctx));
	}
	protected native static int avfilter_graph_config(@Ptr long graphctx, @Ptr long log_ctx);
	/**
	 * Free a graph, destroy its links, and set *graph to NULL.<br>
	 * If *graph is NULL, do nothing.<br>
	 * Original signature : <code>void avfilter_graph_free(AVFilterGraph**)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:1016</i>
	 */
	public static void avfilter_graph_free(Pointer<Pointer<AVFilterGraph > > graph) {
		avfilter_graph_free(Pointer.getPeer(graph));
	}
	protected native static void avfilter_graph_free(@Ptr long graph);
	/**
	 * Allocate a single AVFilterInOut entry.<br>
	 * Must be freed with avfilter_inout_free().<br>
	 * @return allocated AVFilterInOut on success, NULL on failure.<br>
	 * Original signature : <code>AVFilterInOut* avfilter_inout_alloc()</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:1041</i>
	 */
	public static Pointer<AVFilterInOut > avfilter_inout_alloc() {
		return Pointer.pointerToAddress(avfilter_inout_alloc$2(), AVFilterInOut.class);
	}
	@Ptr 
	protected native static long avfilter_inout_alloc$2();
	/**
	 * Free the supplied list of AVFilterInOut and set *inout to NULL.<br>
	 * If *inout is NULL, do nothing.<br>
	 * Original signature : <code>void avfilter_inout_free(AVFilterInOut**)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:1047</i>
	 */
	public static void avfilter_inout_free(Pointer<Pointer<AVFilterInOut > > inout) {
		avfilter_inout_free(Pointer.getPeer(inout));
	}
	protected native static void avfilter_inout_free(@Ptr long inout);
	/**
	 * Add a graph described by a string to a graph.<br>
	 * * @note The caller must provide the lists of inputs and outputs,<br>
	 * which therefore must be known before calling the function.<br>
	 * * @note The inputs parameter describes inputs of the already existing<br>
	 * part of the graph; i.e. from the point of view of the newly created<br>
	 * part, they are outputs. Similarly the outputs parameter describes<br>
	 * outputs of the already existing filters, which are provided as<br>
	 * inputs to the parsed filters.<br>
	 * * @param graph   the filter graph where to link the parsed graph context<br>
	 * @param filters string to be parsed<br>
	 * @param inputs  linked list to the inputs of the graph<br>
	 * @param outputs linked list to the outputs of the graph<br>
	 * @return zero on success, a negative AVERROR code on error<br>
	 * Original signature : <code>int avfilter_graph_parse(AVFilterGraph*, const char*, AVFilterInOut*, AVFilterInOut*, void*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:1064</i>
	 */
	public static int avfilter_graph_parse(Pointer<AVFilterGraph > graph, Pointer<Byte > filters, Pointer<AVFilterInOut > inputs, Pointer<AVFilterInOut > outputs, Pointer<? > log_ctx) {
		return avfilter_graph_parse(Pointer.getPeer(graph), Pointer.getPeer(filters), Pointer.getPeer(inputs), Pointer.getPeer(outputs), Pointer.getPeer(log_ctx));
	}
	protected native static int avfilter_graph_parse(@Ptr long graph, @Ptr long filters, @Ptr long inputs, @Ptr long outputs, @Ptr long log_ctx);
	/**
	 * Add a graph described by a string to a graph.<br>
	 * * In the graph filters description, if the input label of the first<br>
	 * filter is not specified, "in" is assumed; if the output label of<br>
	 * the last filter is not specified, "out" is assumed.<br>
	 * * @param graph   the filter graph where to link the parsed graph context<br>
	 * @param filters string to be parsed<br>
	 * @param inputs  pointer to a linked list to the inputs of the graph, may be NULL.<br>
	 *                If non-NULL, *inputs is updated to contain the list of open inputs<br>
	 *                after the parsing, should be freed with avfilter_inout_free().<br>
	 * @param outputs pointer to a linked list to the outputs of the graph, may be NULL.<br>
	 *                If non-NULL, *outputs is updated to contain the list of open outputs<br>
	 *                after the parsing, should be freed with avfilter_inout_free().<br>
	 * @return non negative on success, a negative AVERROR code on error<br>
	 * Original signature : <code>int avfilter_graph_parse_ptr(AVFilterGraph*, const char*, AVFilterInOut**, AVFilterInOut**, void*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:1081</i>
	 */
	public static int avfilter_graph_parse_ptr(Pointer<AVFilterGraph > graph, Pointer<Byte > filters, Pointer<Pointer<AVFilterInOut > > inputs, Pointer<Pointer<AVFilterInOut > > outputs, Pointer<? > log_ctx) {
		return avfilter_graph_parse_ptr(Pointer.getPeer(graph), Pointer.getPeer(filters), Pointer.getPeer(inputs), Pointer.getPeer(outputs), Pointer.getPeer(log_ctx));
	}
	protected native static int avfilter_graph_parse_ptr(@Ptr long graph, @Ptr long filters, @Ptr long inputs, @Ptr long outputs, @Ptr long log_ctx);
	/**
	 * Add a graph described by a string to a graph.<br>
	 * * @param[in]  graph   the filter graph where to link the parsed graph context<br>
	 * @param[in]  filters string to be parsed<br>
	 * @param[out] inputs  a linked list of all free (unlinked) inputs of the<br>
	 *                     parsed graph will be returned here. It is to be freed<br>
	 *                     by the caller using avfilter_inout_free().<br>
	 * @param[out] outputs a linked list of all free (unlinked) outputs of the<br>
	 *                     parsed graph will be returned here. It is to be freed by the<br>
	 *                     caller using avfilter_inout_free().<br>
	 * @return zero on success, a negative AVERROR code on error<br>
	 * * @note This function returns the inputs and outputs that are left<br>
	 * unlinked after parsing the graph and the caller then deals with<br>
	 * them.<br>
	 * @note This function makes no reference whatsoever to already<br>
	 * existing parts of the graph and the inputs parameter will on return<br>
	 * contain inputs of the newly parsed part of the graph.  Analogously<br>
	 * the outputs parameter will contain outputs of the newly created<br>
	 * filters.<br>
	 * Original signature : <code>int avfilter_graph_parse2(AVFilterGraph*, const char*, AVFilterInOut**, AVFilterInOut**)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:1103</i>
	 */
	public static int avfilter_graph_parse2(Pointer<AVFilterGraph > graph, Pointer<Byte > filters, Pointer<Pointer<AVFilterInOut > > inputs, Pointer<Pointer<AVFilterInOut > > outputs) {
		return avfilter_graph_parse2(Pointer.getPeer(graph), Pointer.getPeer(filters), Pointer.getPeer(inputs), Pointer.getPeer(outputs));
	}
	protected native static int avfilter_graph_parse2(@Ptr long graph, @Ptr long filters, @Ptr long inputs, @Ptr long outputs);
	/**
	 * Send a command to one or more filter instances.<br>
	 * * @param graph  the filter graph<br>
	 * @param target the filter(s) to which the command should be sent<br>
	 *               "all" sends to all filters<br>
	 *               otherwise it can be a filter or filter instance name<br>
	 *               which will send the command to all matching filters.<br>
	 * @param cmd    the command to send, for handling simplicity all commands must be alphanumeric only<br>
	 * @param arg    the argument for the command<br>
	 * @param res    a buffer with size res_size where the filter(s) can return a response.<br>
	 * * @returns >=0 on success otherwise an error code.<br>
	 *              AVERROR(ENOSYS) on unsupported commands<br>
	 * Original signature : <code>int avfilter_graph_send_command(AVFilterGraph*, const char*, const char*, const char*, char*, int, int)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:1118</i>
	 */
	public static int avfilter_graph_send_command(Pointer<AVFilterGraph > graph, Pointer<Byte > target, Pointer<Byte > cmd, Pointer<Byte > arg, Pointer<Byte > res, int res_len, int flags) {
		return avfilter_graph_send_command(Pointer.getPeer(graph), Pointer.getPeer(target), Pointer.getPeer(cmd), Pointer.getPeer(arg), Pointer.getPeer(res), res_len, flags);
	}
	protected native static int avfilter_graph_send_command(@Ptr long graph, @Ptr long target, @Ptr long cmd, @Ptr long arg, @Ptr long res, int res_len, int flags);
	/**
	 * Queue a command for one or more filter instances.<br>
	 * * @param graph  the filter graph<br>
	 * @param target the filter(s) to which the command should be sent<br>
	 *               "all" sends to all filters<br>
	 *               otherwise it can be a filter or filter instance name<br>
	 *               which will send the command to all matching filters.<br>
	 * @param cmd    the command to sent, for handling simplicity all commands must be alphanumeric only<br>
	 * @param arg    the argument for the command<br>
	 * @param ts     time at which the command should be sent to the filter<br>
	 * * @note As this executes commands after this function returns, no return code<br>
	 *       from the filter is provided, also AVFILTER_CMD_FLAG_ONE is not supported.<br>
	 * Original signature : <code>int avfilter_graph_queue_command(AVFilterGraph*, const char*, const char*, const char*, int, double)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:1133</i>
	 */
	public static int avfilter_graph_queue_command(Pointer<AVFilterGraph > graph, Pointer<Byte > target, Pointer<Byte > cmd, Pointer<Byte > arg, int flags, double ts) {
		return avfilter_graph_queue_command(Pointer.getPeer(graph), Pointer.getPeer(target), Pointer.getPeer(cmd), Pointer.getPeer(arg), flags, ts);
	}
	protected native static int avfilter_graph_queue_command(@Ptr long graph, @Ptr long target, @Ptr long cmd, @Ptr long arg, int flags, double ts);
	/**
	 * Dump a graph into a human-readable string representation.<br>
	 * * @param graph    the graph to dump<br>
	 * @param options  formatting options; currently ignored<br>
	 * @return  a string, or NULL in case of memory allocation failure;<br>
	 *          the string must be freed using av_free<br>
	 * Original signature : <code>char* avfilter_graph_dump(AVFilterGraph*, const char*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:1142</i>
	 */
	public static Pointer<Byte > avfilter_graph_dump(Pointer<AVFilterGraph > graph, Pointer<Byte > options) {
		return Pointer.pointerToAddress(avfilter_graph_dump(Pointer.getPeer(graph), Pointer.getPeer(options)), Byte.class);
	}
	@Ptr 
	protected native static long avfilter_graph_dump(@Ptr long graph, @Ptr long options);
	/**
	 * Request a frame on the oldest sink link.<br>
	 * * If the request returns AVERROR_EOF, try the next.<br>
	 * * Note that this function is not meant to be the sole scheduling mechanism<br>
	 * of a filtergraph, only a convenience function to help drain a filtergraph<br>
	 * in a balanced way under normal circumstances.<br>
	 * * Also note that AVERROR_EOF does not mean that frames did not arrive on<br>
	 * some of the sinks during the process.<br>
	 * When there are multiple sink links, in case the requested link<br>
	 * returns an EOF, this may cause a filter to flush pending frames<br>
	 * which are sent to another sink link, although unrequested.<br>
	 * * @return  the return value of ff_request_frame(),<br>
	 *          or AVERROR_EOF if all links returned AVERROR_EOF<br>
	 * Original signature : <code>int avfilter_graph_request_oldest(AVFilterGraph*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:1158</i>
	 */
	public static int avfilter_graph_request_oldest(Pointer<AVFilterGraph > graph) {
		return avfilter_graph_request_oldest(Pointer.getPeer(graph));
	}
	protected native static int avfilter_graph_request_oldest(@Ptr long graph);
	/**
	 * Queue an audio buffer to the audio buffer source.<br>
	 * * @param abuffersrc audio source buffer context<br>
	 * @param data pointers to the samples planes<br>
	 * @param linesize linesizes of each audio buffer plane<br>
	 * @param nb_samples number of samples per channel<br>
	 * @param sample_fmt sample format of the audio data<br>
	 * @param ch_layout channel layout of the audio data<br>
	 * @param planar flag to indicate if audio data is planar or packed<br>
	 * @param pts presentation timestamp of the audio buffer<br>
	 * @param flags unused<br>
	 * * @deprecated use av_buffersrc_add_ref() instead.<br>
	 * Original signature : <code>int av_asrc_buffer_add_samples(AVFilterContext*, uint8_t*[8], int[8], int, int, int, int64_t, int, int64_t, int)</code><br>
	 * <i>native declaration : libavfilter/asrc_abuffer.h:14</i>
	 */
	public static int av_asrc_buffer_add_samples(Pointer<AVFilterContext > abuffersrc, Pointer<Pointer<Byte > > data, Pointer<Integer > linesize, int nb_samples, int sample_rate, int sample_fmt, long ch_layout, int planar, long pts, int flags) {
		return av_asrc_buffer_add_samples(Pointer.getPeer(abuffersrc), Pointer.getPeer(data), Pointer.getPeer(linesize), nb_samples, sample_rate, sample_fmt, ch_layout, planar, pts, flags);
	}
	protected native static int av_asrc_buffer_add_samples(@Ptr long abuffersrc, @Ptr long data, @Ptr long linesize, int nb_samples, int sample_rate, int sample_fmt, long ch_layout, int planar, long pts, int flags);
	/**
	 * Queue an audio buffer to the audio buffer source.<br>
	 * * This is similar to av_asrc_buffer_add_samples(), but the samples<br>
	 * are stored in a buffer with known size.<br>
	 * * @param abuffersrc audio source buffer context<br>
	 * @param buf pointer to the samples data, packed is assumed<br>
	 * @param size the size in bytes of the buffer, it must contain an<br>
	 * integer number of samples<br>
	 * @param sample_fmt sample format of the audio data<br>
	 * @param ch_layout channel layout of the audio data<br>
	 * @param pts presentation timestamp of the audio buffer<br>
	 * @param flags unused<br>
	 * * @deprecated use av_buffersrc_add_ref() instead.<br>
	 * Original signature : <code>int av_asrc_buffer_add_buffer(AVFilterContext*, uint8_t*, int, int, int, int64_t, int, int64_t, int)</code><br>
	 * <i>native declaration : libavfilter/asrc_abuffer.h:30</i>
	 */
	public static int av_asrc_buffer_add_buffer(Pointer<AVFilterContext > abuffersrc, Pointer<Byte > buf, int buf_size, int sample_rate, int sample_fmt, long ch_layout, int planar, long pts, int flags) {
		return av_asrc_buffer_add_buffer(Pointer.getPeer(abuffersrc), Pointer.getPeer(buf), buf_size, sample_rate, sample_fmt, ch_layout, planar, pts, flags);
	}
	protected native static int av_asrc_buffer_add_buffer(@Ptr long abuffersrc, @Ptr long buf, int buf_size, int sample_rate, int sample_fmt, long ch_layout, int planar, long pts, int flags);
	/**
	 * Queue an audio buffer to the audio buffer source.<br>
	 * * @param abuffersrc audio source buffer context<br>
	 * @param samplesref buffer ref to queue<br>
	 * @param flags unused<br>
	 * * @deprecated use av_buffersrc_add_ref() instead.<br>
	 * Original signature : <code>int av_asrc_buffer_add_audio_buffer_ref(AVFilterContext*, AVFilterBufferRef*, int)</code><br>
	 * <i>native declaration : libavfilter/asrc_abuffer.h:39</i>
	 */
	public static int av_asrc_buffer_add_audio_buffer_ref(Pointer<AVFilterContext > abuffersrc, Pointer<AVFilterBufferRef > samplesref, int flags) {
		return av_asrc_buffer_add_audio_buffer_ref(Pointer.getPeer(abuffersrc), Pointer.getPeer(samplesref), flags);
	}
	protected native static int av_asrc_buffer_add_audio_buffer_ref(@Ptr long abuffersrc, @Ptr long samplesref, int flags);
	/**
	 * Create and return a picref reference from the data and properties<br>
	 * contained in frame.<br>
	 * * @param perms permissions to assign to the new buffer reference<br>
	 * @deprecated avfilter APIs work natively with AVFrame instead.<br>
	 * Original signature : <code>AVFilterBufferRef* avfilter_get_video_buffer_ref_from_frame(const AVFrame*, int)</code><br>
	 * <i>native declaration : libavfilter/avcodec.h:7</i>
	 */
	public static Pointer<AVFilterBufferRef > avfilter_get_video_buffer_ref_from_frame(Pointer<AVFrame > frame, int perms) {
		return Pointer.pointerToAddress(avfilter_get_video_buffer_ref_from_frame(Pointer.getPeer(frame), perms), AVFilterBufferRef.class);
	}
	@Ptr 
	protected native static long avfilter_get_video_buffer_ref_from_frame(@Ptr long frame, int perms);
	/**
	 * Create and return a picref reference from the data and properties<br>
	 * contained in frame.<br>
	 * * @param perms permissions to assign to the new buffer reference<br>
	 * @deprecated avfilter APIs work natively with AVFrame instead.<br>
	 * Original signature : <code>AVFilterBufferRef* avfilter_get_audio_buffer_ref_from_frame(const AVFrame*, int)</code><br>
	 * <i>native declaration : libavfilter/avcodec.h:15</i>
	 */
	public static Pointer<AVFilterBufferRef > avfilter_get_audio_buffer_ref_from_frame(Pointer<AVFrame > frame, int perms) {
		return Pointer.pointerToAddress(avfilter_get_audio_buffer_ref_from_frame(Pointer.getPeer(frame), perms), AVFilterBufferRef.class);
	}
	@Ptr 
	protected native static long avfilter_get_audio_buffer_ref_from_frame(@Ptr long frame, int perms);
	/**
	 * Create and return a buffer reference from the data and properties<br>
	 * contained in frame.<br>
	 * * @param perms permissions to assign to the new buffer reference<br>
	 * @deprecated avfilter APIs work natively with AVFrame instead.<br>
	 * Original signature : <code>AVFilterBufferRef* avfilter_get_buffer_ref_from_frame(AVMediaType, const AVFrame*, int)</code><br>
	 * <i>native declaration : libavfilter/avcodec.h:23</i>
	 */
	public static Pointer<AVFilterBufferRef > avfilter_get_buffer_ref_from_frame(IntValuedEnum<AVMediaType > type, Pointer<AVFrame > frame, int perms) {
		return Pointer.pointerToAddress(avfilter_get_buffer_ref_from_frame((int)type.value(), Pointer.getPeer(frame), perms), AVFilterBufferRef.class);
	}
	@Ptr 
	protected native static long avfilter_get_buffer_ref_from_frame(int type, @Ptr long frame, int perms);
	/**
	 * Get an audio/video buffer data from buffer_sink and put it in bufref.<br>
	 * * This function works with both audio and video buffer sinks.<br>
	 * * @param buffer_sink pointer to a buffersink or abuffersink context<br>
	 * @param flags a combination of AV_BUFFERSINK_FLAG_* flags<br>
	 * @return >= 0 in case of success, a negative AVERROR code in case of<br>
	 * failure<br>
	 * Original signature : <code>int av_buffersink_get_buffer_ref(AVFilterContext*, AVFilterBufferRef**, int)</code><br>
	 * <i>native declaration : libavfilter/buffersink.h:9</i>
	 */
	public static int av_buffersink_get_buffer_ref(Pointer<AVFilterContext > buffer_sink, Pointer<Pointer<AVFilterBufferRef > > bufref, int flags) {
		return av_buffersink_get_buffer_ref(Pointer.getPeer(buffer_sink), Pointer.getPeer(bufref), flags);
	}
	protected native static int av_buffersink_get_buffer_ref(@Ptr long buffer_sink, @Ptr long bufref, int flags);
	/**
	 * Get the number of immediately available frames.<br>
	 * Original signature : <code>int av_buffersink_poll_frame(AVFilterContext*)</code><br>
	 * <i>native declaration : libavfilter/buffersink.h:14</i>
	 */
	public static int av_buffersink_poll_frame(Pointer<AVFilterContext > ctx) {
		return av_buffersink_poll_frame(Pointer.getPeer(ctx));
	}
	protected native static int av_buffersink_poll_frame(@Ptr long ctx);
	/**
	 * Get a buffer with filtered data from sink and put it in buf.<br>
	 * * @param ctx pointer to a context of a buffersink or abuffersink AVFilter.<br>
	 * @param buf pointer to the buffer will be written here if buf is non-NULL. buf<br>
	 *            must be freed by the caller using avfilter_unref_buffer().<br>
	 *            Buf may also be NULL to query whether a buffer is ready to be<br>
	 *            output.<br>
	 * * @return >= 0 in case of success, a negative AVERROR code in case of<br>
	 *         failure.<br>
	 * Original signature : <code>int av_buffersink_read(AVFilterContext*, AVFilterBufferRef**)</code><br>
	 * <i>native declaration : libavfilter/buffersink.h:26</i>
	 */
	public static int av_buffersink_read(Pointer<AVFilterContext > ctx, Pointer<Pointer<AVFilterBufferRef > > buf) {
		return av_buffersink_read(Pointer.getPeer(ctx), Pointer.getPeer(buf));
	}
	protected native static int av_buffersink_read(@Ptr long ctx, @Ptr long buf);
	/**
	 * Same as av_buffersink_read, but with the ability to specify the number of<br>
	 * samples read. This function is less efficient than av_buffersink_read(),<br>
	 * because it copies the data around.<br>
	 * * @param ctx pointer to a context of the abuffersink AVFilter.<br>
	 * @param buf pointer to the buffer will be written here if buf is non-NULL. buf<br>
	 *            must be freed by the caller using avfilter_unref_buffer(). buf<br>
	 *            will contain exactly nb_samples audio samples, except at the end<br>
	 *            of stream, when it can contain less than nb_samples.<br>
	 *            Buf may also be NULL to query whether a buffer is ready to be<br>
	 *            output.<br>
	 * * @warning do not mix this function with av_buffersink_read(). Use only one or<br>
	 * the other with a single sink, not both.<br>
	 * Original signature : <code>int av_buffersink_read_samples(AVFilterContext*, AVFilterBufferRef**, int)</code><br>
	 * <i>native declaration : libavfilter/buffersink.h:42</i>
	 */
	public static int av_buffersink_read_samples(Pointer<AVFilterContext > ctx, Pointer<Pointer<AVFilterBufferRef > > buf, int nb_samples) {
		return av_buffersink_read_samples(Pointer.getPeer(ctx), Pointer.getPeer(buf), nb_samples);
	}
	protected native static int av_buffersink_read_samples(@Ptr long ctx, @Ptr long buf, int nb_samples);
	/**
	 * Get a frame with filtered data from sink and put it in frame.<br>
	 * * @param ctx    pointer to a buffersink or abuffersink filter context.<br>
	 * @param frame  pointer to an allocated frame that will be filled with data.<br>
	 *               The data must be freed using av_frame_unref() / av_frame_free()<br>
	 * @param flags  a combination of AV_BUFFERSINK_FLAG_* flags<br>
	 * * @return  >= 0 in for success, a negative AVERROR code for failure.<br>
	 * Original signature : <code>int av_buffersink_get_frame_flags(AVFilterContext*, AVFrame*, int)</code><br>
	 * <i>native declaration : libavfilter/buffersink.h:52</i>
	 */
	public static int av_buffersink_get_frame_flags(Pointer<AVFilterContext > ctx, Pointer<AVFrame > frame, int flags) {
		return av_buffersink_get_frame_flags(Pointer.getPeer(ctx), Pointer.getPeer(frame), flags);
	}
	protected native static int av_buffersink_get_frame_flags(@Ptr long ctx, @Ptr long frame, int flags);
	/**
	 * Create an AVBufferSinkParams structure.<br>
	 * * Must be freed with av_free().<br>
	 * Original signature : <code>AVBufferSinkParams* av_buffersink_params_alloc()</code><br>
	 * <i>native declaration : libavfilter/buffersink.h:65</i>
	 */
	public static Pointer<AVBufferSinkParams > av_buffersink_params_alloc() {
		return Pointer.pointerToAddress(av_buffersink_params_alloc$2(), AVBufferSinkParams.class);
	}
	@Ptr 
	protected native static long av_buffersink_params_alloc$2();
	/**
	 * Create an AVABufferSinkParams structure.<br>
	 * * Must be freed with av_free().<br>
	 * Original signature : <code>AVABufferSinkParams* av_abuffersink_params_alloc()</code><br>
	 * <i>native declaration : libavfilter/buffersink.h:86</i>
	 */
	public static Pointer<AVABufferSinkParams > av_abuffersink_params_alloc() {
		return Pointer.pointerToAddress(av_abuffersink_params_alloc$2(), AVABufferSinkParams.class);
	}
	@Ptr 
	protected native static long av_abuffersink_params_alloc$2();
	/**
	 * Set the frame size for an audio buffer sink.<br>
	 * * All calls to av_buffersink_get_buffer_ref will return a buffer with<br>
	 * exactly the specified number of samples, or AVERROR(EAGAIN) if there is<br>
	 * not enough. The last buffer at EOF will be padded with 0.<br>
	 * Original signature : <code>void av_buffersink_set_frame_size(AVFilterContext*, unsigned)</code><br>
	 * <i>native declaration : libavfilter/buffersink.h:94</i>
	 */
	public static void av_buffersink_set_frame_size(Pointer<AVFilterContext > ctx, int frame_size) {
		av_buffersink_set_frame_size(Pointer.getPeer(ctx), frame_size);
	}
	protected native static void av_buffersink_set_frame_size(@Ptr long ctx, int frame_size);
	/**
	 * Get the frame rate of the input.<br>
	 * Original signature : <code>AVRational av_buffersink_get_frame_rate(AVFilterContext*)</code><br>
	 * <i>native declaration : libavfilter/buffersink.h:99</i>
	 */
	public static AVRational av_buffersink_get_frame_rate(Pointer<AVFilterContext > ctx) {
		return av_buffersink_get_frame_rate(Pointer.getPeer(ctx));
	}
	protected native static AVRational av_buffersink_get_frame_rate(@Ptr long ctx);
	/**
	 * Get a frame with filtered data from sink and put it in frame.<br>
	 * * @param ctx pointer to a context of a buffersink or abuffersink AVFilter.<br>
	 * @param frame pointer to an allocated frame that will be filled with data.<br>
	 *              The data must be freed using av_frame_unref() / av_frame_free()<br>
	 * * @return<br>
	 *         - >= 0 if a frame was successfully returned.<br>
	 *         - AVERROR(EAGAIN) if no frames are available at this point; more<br>
	 *           input frames must be added to the filtergraph to get more output.<br>
	 *         - AVERROR_EOF if there will be no more output frames on this sink.<br>
	 *         - A different negative AVERROR code in other failure cases.<br>
	 * Original signature : <code>int av_buffersink_get_frame(AVFilterContext*, AVFrame*)</code><br>
	 * <i>native declaration : libavfilter/buffersink.h:113</i>
	 */
	public static int av_buffersink_get_frame(Pointer<AVFilterContext > ctx, Pointer<AVFrame > frame) {
		return av_buffersink_get_frame(Pointer.getPeer(ctx), Pointer.getPeer(frame));
	}
	protected native static int av_buffersink_get_frame(@Ptr long ctx, @Ptr long frame);
	/**
	 * Same as av_buffersink_get_frame(), but with the ability to specify the number<br>
	 * of samples read. This function is less efficient than<br>
	 * av_buffersink_get_frame(), because it copies the data around.<br>
	 * * @param ctx pointer to a context of the abuffersink AVFilter.<br>
	 * @param frame pointer to an allocated frame that will be filled with data.<br>
	 *              The data must be freed using av_frame_unref() / av_frame_free()<br>
	 *              frame will contain exactly nb_samples audio samples, except at<br>
	 *              the end of stream, when it can contain less than nb_samples.<br>
	 * * @return The return codes have the same meaning as for<br>
	 *         av_buffersink_get_samples().<br>
	 * * @warning do not mix this function with av_buffersink_get_frame(). Use only one or<br>
	 * the other with a single sink, not both.<br>
	 * Original signature : <code>int av_buffersink_get_samples(AVFilterContext*, AVFrame*, int)</code><br>
	 * <i>native declaration : libavfilter/buffersink.h:129</i>
	 */
	public static int av_buffersink_get_samples(Pointer<AVFilterContext > ctx, Pointer<AVFrame > frame, int nb_samples) {
		return av_buffersink_get_samples(Pointer.getPeer(ctx), Pointer.getPeer(frame), nb_samples);
	}
	protected native static int av_buffersink_get_samples(@Ptr long ctx, @Ptr long frame, int nb_samples);
	/**
	 * Add buffer data in picref to buffer_src.<br>
	 * * @param buffer_src  pointer to a buffer source context<br>
	 * @param picref      a buffer reference, or NULL to mark EOF<br>
	 * @param flags       a combination of AV_BUFFERSRC_FLAG_*<br>
	 * @return            >= 0 in case of success, a negative AVERROR code<br>
	 *                    in case of failure<br>
	 * Original signature : <code>int av_buffersrc_add_ref(AVFilterContext*, AVFilterBufferRef*, int)</code><br>
	 * <i>native declaration : libavfilter/buffersrc.h:23</i>
	 */
	public static int av_buffersrc_add_ref(Pointer<AVFilterContext > buffer_src, Pointer<AVFilterBufferRef > picref, int flags) {
		return av_buffersrc_add_ref(Pointer.getPeer(buffer_src), Pointer.getPeer(picref), flags);
	}
	protected native static int av_buffersrc_add_ref(@Ptr long buffer_src, @Ptr long picref, int flags);
	/**
	 * Get the number of failed requests.<br>
	 * * A failed request is when the request_frame method is called while no<br>
	 * frame is present in the buffer.<br>
	 * The number is reset when a frame is added.<br>
	 * Original signature : <code>int av_buffersrc_get_nb_failed_requests(AVFilterContext*)</code><br>
	 * <i>native declaration : libavfilter/buffersrc.h:31</i>
	 */
	public static int av_buffersrc_get_nb_failed_requests(Pointer<AVFilterContext > buffer_src) {
		return av_buffersrc_get_nb_failed_requests(Pointer.getPeer(buffer_src));
	}
	protected native static int av_buffersrc_get_nb_failed_requests(@Ptr long buffer_src);
	/**
	 * Add a buffer to a filtergraph.<br>
	 * * @param ctx an instance of the buffersrc filter<br>
	 * @param buf buffer containing frame data to be passed down the filtergraph.<br>
	 * This function will take ownership of buf, the user must not free it.<br>
	 * A NULL buf signals EOF -- i.e. no more frames will be sent to this filter.<br>
	 * * @deprecated use av_buffersrc_write_frame() or av_buffersrc_add_frame()<br>
	 * Original signature : <code>int av_buffersrc_buffer(AVFilterContext*, AVFilterBufferRef*)</code><br>
	 * <i>native declaration : libavfilter/buffersrc.h:41</i>
	 */
	public static int av_buffersrc_buffer(Pointer<AVFilterContext > ctx, Pointer<AVFilterBufferRef > buf) {
		return av_buffersrc_buffer(Pointer.getPeer(ctx), Pointer.getPeer(buf));
	}
	protected native static int av_buffersrc_buffer(@Ptr long ctx, @Ptr long buf);
	/**
	 * Add a frame to the buffer source.<br>
	 * * @param ctx   an instance of the buffersrc filter<br>
	 * @param frame frame to be added. If the frame is reference counted, this<br>
	 * function will make a new reference to it. Otherwise the frame data will be<br>
	 * copied.<br>
	 * * @return 0 on success, a negative AVERROR on error<br>
	 * * This function is equivalent to av_buffersrc_add_frame_flags() with the<br>
	 * AV_BUFFERSRC_FLAG_KEEP_REF flag.<br>
	 * Original signature : <code>int av_buffersrc_write_frame(AVFilterContext*, const AVFrame*)</code><br>
	 * <i>native declaration : libavfilter/buffersrc.h:53</i>
	 */
	public static int av_buffersrc_write_frame(Pointer<AVFilterContext > ctx, Pointer<AVFrame > frame) {
		return av_buffersrc_write_frame(Pointer.getPeer(ctx), Pointer.getPeer(frame));
	}
	protected native static int av_buffersrc_write_frame(@Ptr long ctx, @Ptr long frame);
	/**
	 * Add a frame to the buffer source.<br>
	 * * @param ctx   an instance of the buffersrc filter<br>
	 * @param frame frame to be added. If the frame is reference counted, this<br>
	 * function will take ownership of the reference(s) and reset the frame.<br>
	 * Otherwise the frame data will be copied. If this function returns an error,<br>
	 * the input frame is not touched.<br>
	 * * @return 0 on success, a negative AVERROR on error.<br>
	 * * @note the difference between this function and av_buffersrc_write_frame() is<br>
	 * that av_buffersrc_write_frame() creates a new reference to the input frame,<br>
	 * while this function takes ownership of the reference passed to it.<br>
	 * * This function is equivalent to av_buffersrc_add_frame_flags() without the<br>
	 * AV_BUFFERSRC_FLAG_KEEP_REF flag.<br>
	 * Original signature : <code>int av_buffersrc_add_frame(AVFilterContext*, AVFrame*)</code><br>
	 * <i>native declaration : libavfilter/buffersrc.h:69</i>
	 */
	public static int av_buffersrc_add_frame(Pointer<AVFilterContext > ctx, Pointer<AVFrame > frame) {
		return av_buffersrc_add_frame(Pointer.getPeer(ctx), Pointer.getPeer(frame));
	}
	protected native static int av_buffersrc_add_frame(@Ptr long ctx, @Ptr long frame);
	/**
	 * Add a frame to the buffer source.<br>
	 * * By default, if the frame is reference-counted, this function will take<br>
	 * ownership of the reference(s) and reset the frame. This can be controlled<br>
	 * using the flags.<br>
	 * * If this function returns an error, the input frame is not touched.<br>
	 * * @param buffer_src  pointer to a buffer source context<br>
	 * @param frame       a frame, or NULL to mark EOF<br>
	 * @param flags       a combination of AV_BUFFERSRC_FLAG_*<br>
	 * @return            >= 0 in case of success, a negative AVERROR code<br>
	 *                    in case of failure<br>
	 * Original signature : <code>int av_buffersrc_add_frame_flags(AVFilterContext*, AVFrame*, int)</code><br>
	 * <i>native declaration : libavfilter/buffersrc.h:83</i>
	 */
	public static int av_buffersrc_add_frame_flags(Pointer<AVFilterContext > buffer_src, Pointer<AVFrame > frame, int flags) {
		return av_buffersrc_add_frame_flags(Pointer.getPeer(buffer_src), Pointer.getPeer(frame), flags);
	}
	protected native static int av_buffersrc_add_frame_flags(@Ptr long buffer_src, @Ptr long frame, int flags);
	/** Undefined type */
	public static interface AVFilterInternal {
		
	};
	/** Undefined type */
	public static interface AVFilterGraphInternal {
		
	};
	/** Undefined type */
	public static interface AVFilterChannelLayouts {
		
	};
	/** Undefined type */
	public static interface AVFilterFormats {
		
	};
	/** Undefined type */
	public static interface AVFilterCommand {
		
	};
	/** Undefined type */
	public static interface AVFilterPool {
		
	};
}
