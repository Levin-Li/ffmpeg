package org.ffmpeg.avutil;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.NativeLong;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import org.ffmpeg.avutil.AVDictionary.ByReference;
/**
 * JNA Wrapper for library <b>avutil</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface AvutilLibrary extends Library {
	public static final String JNA_LIBRARY_NAME = "avutil";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(AvutilLibrary.JNA_LIBRARY_NAME);
	public static final AvutilLibrary INSTANCE = (AvutilLibrary)Native.loadLibrary(AvutilLibrary.JNA_LIBRARY_NAME, AvutilLibrary.class);
	/**
	 * <i>native declaration : libavutil/avutil.h:13</i><br>
	 * enum values
	 */
	public static interface AVMediaType {
		/**
		 * < Usually treated as AVMEDIA_TYPE_DATA<br>
		 * <i>native declaration : libavutil/avutil.h:4</i>
		 */
		public static final int AVMEDIA_TYPE_UNKNOWN = -1;
		/** <i>native declaration : libavutil/avutil.h:5</i> */
		public static final int AVMEDIA_TYPE_VIDEO = 0;
		/** <i>native declaration : libavutil/avutil.h:6</i> */
		public static final int AVMEDIA_TYPE_AUDIO = 1;
		/**
		 * < Opaque data information usually continuous<br>
		 * <i>native declaration : libavutil/avutil.h:8</i>
		 */
		public static final int AVMEDIA_TYPE_DATA = 2;
		/** <i>native declaration : libavutil/avutil.h:9</i> */
		public static final int AVMEDIA_TYPE_SUBTITLE = 3;
		/**
		 * < Opaque data information usually sparse<br>
		 * <i>native declaration : libavutil/avutil.h:11</i>
		 */
		public static final int AVMEDIA_TYPE_ATTACHMENT = 4;
		/** <i>native declaration : libavutil/avutil.h:12</i> */
		public static final int AVMEDIA_TYPE_NB = 5;
	};
	/**
	 * <i>native declaration : libavutil/avutil.h:33</i><br>
	 * enum values
	 */
	public static interface AVPictureType {
		/**
		 * < Undefined<br>
		 * <i>native declaration : libavutil/avutil.h:18</i>
		 */
		public static final int AV_PICTURE_TYPE_NONE = 0;
		/**
		 * < Intra<br>
		 * <i>native declaration : libavutil/avutil.h:20</i>
		 */
		public static final int AV_PICTURE_TYPE_I = 1;
		/**
		 * < Predicted<br>
		 * <i>native declaration : libavutil/avutil.h:22</i>
		 */
		public static final int AV_PICTURE_TYPE_P = 2;
		/**
		 * < Bi-dir predicted<br>
		 * <i>native declaration : libavutil/avutil.h:24</i>
		 */
		public static final int AV_PICTURE_TYPE_B = 3;
		/**
		 * < S(GMC)-VOP MPEG4<br>
		 * <i>native declaration : libavutil/avutil.h:26</i>
		 */
		public static final int AV_PICTURE_TYPE_S = 4;
		/**
		 * < Switching Intra<br>
		 * <i>native declaration : libavutil/avutil.h:28</i>
		 */
		public static final int AV_PICTURE_TYPE_SI = 5;
		/**
		 * < Switching Predicted<br>
		 * <i>native declaration : libavutil/avutil.h:30</i>
		 */
		public static final int AV_PICTURE_TYPE_SP = 6;
		/**
		 * < BI type<br>
		 * <i>native declaration : libavutil/avutil.h:32</i>
		 */
		public static final int AV_PICTURE_TYPE_BI = 7;
	};
	/**
	 * <i>native declaration : libavutil/samplefmt.h:24</i><br>
	 * enum values
	 */
	public static interface AVSampleFormat {
		/** <i>native declaration : libavutil/samplefmt.h:1</i> */
		public static final int AV_SAMPLE_FMT_NONE = -1;
		/**
		 * < unsigned 8 bits<br>
		 * <i>native declaration : libavutil/samplefmt.h:3</i>
		 */
		public static final int AV_SAMPLE_FMT_U8 = 0;
		/**
		 * < signed 16 bits<br>
		 * <i>native declaration : libavutil/samplefmt.h:5</i>
		 */
		public static final int AV_SAMPLE_FMT_S16 = 1;
		/**
		 * < signed 32 bits<br>
		 * <i>native declaration : libavutil/samplefmt.h:7</i>
		 */
		public static final int AV_SAMPLE_FMT_S32 = 2;
		/**
		 * < float<br>
		 * <i>native declaration : libavutil/samplefmt.h:9</i>
		 */
		public static final int AV_SAMPLE_FMT_FLT = 3;
		/**
		 * < double<br>
		 * <i>native declaration : libavutil/samplefmt.h:11</i>
		 */
		public static final int AV_SAMPLE_FMT_DBL = 4;
		/**
		 * < unsigned 8 bits, planar<br>
		 * <i>native declaration : libavutil/samplefmt.h:13</i>
		 */
		public static final int AV_SAMPLE_FMT_U8P = 5;
		/**
		 * < signed 16 bits, planar<br>
		 * <i>native declaration : libavutil/samplefmt.h:15</i>
		 */
		public static final int AV_SAMPLE_FMT_S16P = 6;
		/**
		 * < signed 32 bits, planar<br>
		 * <i>native declaration : libavutil/samplefmt.h:17</i>
		 */
		public static final int AV_SAMPLE_FMT_S32P = 7;
		/**
		 * < float, planar<br>
		 * <i>native declaration : libavutil/samplefmt.h:19</i>
		 */
		public static final int AV_SAMPLE_FMT_FLTP = 8;
		/**
		 * < double, planar<br>
		 * <i>native declaration : libavutil/samplefmt.h:21</i>
		 */
		public static final int AV_SAMPLE_FMT_DBLP = 9;
		/**
		 * < Number of sample formats. DO NOT USE if linking dynamically<br>
		 * <i>native declaration : libavutil/samplefmt.h:23</i>
		 */
		public static final int AV_SAMPLE_FMT_NB = 10;
	};
	/**
	 * <i>native declaration : libavutil/frame.h:19</i><br>
	 * enum values
	 */
	public static interface AVColorSpace {
		/** <i>native declaration : libavutil/frame.h:1</i> */
		public static final int AVCOL_SPC_RGB = 0;
		/**
		 * < also ITU-R BT1361 / IEC 61966-2-4 xvYCC709 / SMPTE RP177 Annex B<br>
		 * <i>native declaration : libavutil/frame.h:3</i>
		 */
		public static final int AVCOL_SPC_BT709 = 1;
		/** <i>native declaration : libavutil/frame.h:4</i> */
		public static final int AVCOL_SPC_UNSPECIFIED = 2;
		/** <i>native declaration : libavutil/frame.h:5</i> */
		public static final int AVCOL_SPC_FCC = 4;
		/**
		 * < also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM / IEC 61966-2-4 xvYCC601<br>
		 * <i>native declaration : libavutil/frame.h:7</i>
		 */
		public static final int AVCOL_SPC_BT470BG = 5;
		/**
		 * < also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC / functionally identical to above<br>
		 * <i>native declaration : libavutil/frame.h:9</i>
		 */
		public static final int AVCOL_SPC_SMPTE170M = 6;
		/** <i>native declaration : libavutil/frame.h:10</i> */
		public static final int AVCOL_SPC_SMPTE240M = 7;
		/**
		 * < Used by Dirac / VC-2 and H.264 FRext, see ITU-T SG16<br>
		 * <i>native declaration : libavutil/frame.h:12</i>
		 */
		public static final int AVCOL_SPC_YCOCG = 8;
		/**
		 * < ITU-R BT2020 non-constant luminance system<br>
		 * <i>native declaration : libavutil/frame.h:14</i>
		 */
		public static final int AVCOL_SPC_BT2020_NCL = 9;
		/**
		 * < ITU-R BT2020 constant luminance system<br>
		 * <i>native declaration : libavutil/frame.h:16</i>
		 */
		public static final int AVCOL_SPC_BT2020_CL = 10;
		/**
		 * < Not part of ABI<br>
		 * <i>native declaration : libavutil/frame.h:18</i>
		 */
		public static final int AVCOL_SPC_NB = 11;
	};
	/**
	 * <i>native declaration : libavutil/frame.h:28</i><br>
	 * enum values
	 */
	public static interface AVColorRange {
		/** <i>native declaration : libavutil/frame.h:21</i> */
		public static final int AVCOL_RANGE_UNSPECIFIED = 0;
		/**
		 * < the normal 219*2^(n-8) "MPEG" YUV ranges<br>
		 * <i>native declaration : libavutil/frame.h:23</i>
		 */
		public static final int AVCOL_RANGE_MPEG = 1;
		/**
		 * < the normal     2^n-1   "JPEG" YUV ranges<br>
		 * <i>native declaration : libavutil/frame.h:25</i>
		 */
		public static final int AVCOL_RANGE_JPEG = 2;
		/**
		 * < Not part of ABI<br>
		 * <i>native declaration : libavutil/frame.h:27</i>
		 */
		public static final int AVCOL_RANGE_NB = 3;
	};
	/**
	 * <i>native declaration : libavutil/frame.h:35</i><br>
	 * enum values
	 */
	public static interface AVFrameSideDataType {
		/** <i>native declaration : libavutil/frame.h:30</i> */
		public static final int AV_FRAME_DATA_PANSCAN = 0;
		/** <i>native declaration : libavutil/frame.h:31</i> */
		public static final int AV_FRAME_DATA_A53_CC = 1;
		/** <i>native declaration : libavutil/frame.h:32</i> */
		public static final int AV_FRAME_DATA_STEREO3D = 2;
		/** <i>native declaration : libavutil/frame.h:33</i> */
		public static final int AV_FRAME_DATA_MATRIXENCODING = 3;
		/** <i>native declaration : libavutil/frame.h:34</i> */
		public static final int AV_FRAME_DATA_DOWNMIX_INFO = 4;
	};
	/**
	 * <i>native declaration : libavutil/opt.h:20</i><br>
	 * enum values
	 */
	public static interface AVOptionType {
		/** <i>native declaration : libavutil/opt.h:1</i> */
		public static final int AV_OPT_TYPE_FLAGS = 0;
		/** <i>native declaration : libavutil/opt.h:2</i> */
		public static final int AV_OPT_TYPE_INT = 1;
		/** <i>native declaration : libavutil/opt.h:3</i> */
		public static final int AV_OPT_TYPE_INT64 = 2;
		/** <i>native declaration : libavutil/opt.h:4</i> */
		public static final int AV_OPT_TYPE_DOUBLE = 3;
		/** <i>native declaration : libavutil/opt.h:5</i> */
		public static final int AV_OPT_TYPE_FLOAT = 4;
		/** <i>native declaration : libavutil/opt.h:6</i> */
		public static final int AV_OPT_TYPE_STRING = 5;
		/** <i>native declaration : libavutil/opt.h:7</i> */
		public static final int AV_OPT_TYPE_RATIONAL = 6;
		/**
		 * < offset must point to a pointer immediately followed by an int for the length<br>
		 * <i>native declaration : libavutil/opt.h:9</i>
		 */
		public static final int AV_OPT_TYPE_BINARY = 7;
		/** <i>native declaration : libavutil/opt.h:10</i> */
		public static final int AV_OPT_TYPE_CONST = 128;
		/**
		 * < offset must point to two consecutive integers<br>
		 * <i>native declaration : libavutil/opt.h:12</i>
		 */
		public static final int AV_OPT_TYPE_IMAGE_SIZE = (('E') | (('Z') << 8) | (('I') << 16) | (('S') << 24));
		/** <i>native declaration : libavutil/opt.h:13</i> */
		public static final int AV_OPT_TYPE_PIXEL_FMT = (('T') | (('M') << 8) | (('F') << 16) | (('P') << 24));
		/** <i>native declaration : libavutil/opt.h:14</i> */
		public static final int AV_OPT_TYPE_SAMPLE_FMT = (('T') | (('M') << 8) | (('F') << 16) | (('S') << 24));
		/**
		 * < offset must point to AVRational<br>
		 * <i>native declaration : libavutil/opt.h:16</i>
		 */
		public static final int AV_OPT_TYPE_VIDEO_RATE = (('T') | (('A') << 8) | (('R') << 16) | (('V') << 24));
		/** <i>native declaration : libavutil/opt.h:17</i> */
		public static final int AV_OPT_TYPE_DURATION = ((' ') | (('R') << 8) | (('U') << 16) | (('D') << 24));
		/** <i>native declaration : libavutil/opt.h:18</i> */
		public static final int AV_OPT_TYPE_COLOR = (('R') | (('L') << 8) | (('O') << 16) | (('C') << 24));
		/** <i>native declaration : libavutil/opt.h:19</i> */
		public static final int AV_OPT_TYPE_CHANNEL_LAYOUT = (('A') | (('L') << 8) | (('H') << 16) | (('C') << 24));
	};
	/**
	 * <i>native declaration : libavutil/log.h:13</i><br>
	 * enum values
	 */
	public static interface AVClassCategory {
		/** <i>native declaration : libavutil/log.h:1</i> */
		public static final int AV_CLASS_CATEGORY_NA = 0;
		/** <i>native declaration : libavutil/log.h:2</i> */
		public static final int AV_CLASS_CATEGORY_INPUT = 1;
		/** <i>native declaration : libavutil/log.h:3</i> */
		public static final int AV_CLASS_CATEGORY_OUTPUT = 2;
		/** <i>native declaration : libavutil/log.h:4</i> */
		public static final int AV_CLASS_CATEGORY_MUXER = 3;
		/** <i>native declaration : libavutil/log.h:5</i> */
		public static final int AV_CLASS_CATEGORY_DEMUXER = 4;
		/** <i>native declaration : libavutil/log.h:6</i> */
		public static final int AV_CLASS_CATEGORY_ENCODER = 5;
		/** <i>native declaration : libavutil/log.h:7</i> */
		public static final int AV_CLASS_CATEGORY_DECODER = 6;
		/** <i>native declaration : libavutil/log.h:8</i> */
		public static final int AV_CLASS_CATEGORY_FILTER = 7;
		/** <i>native declaration : libavutil/log.h:9</i> */
		public static final int AV_CLASS_CATEGORY_BITSTREAM_FILTER = 8;
		/** <i>native declaration : libavutil/log.h:10</i> */
		public static final int AV_CLASS_CATEGORY_SWSCALER = 9;
		/** <i>native declaration : libavutil/log.h:11</i> */
		public static final int AV_CLASS_CATEGORY_SWRESAMPLER = 10;
		/** <i>native declaration : libavutil/log.h:12</i> */
		public static final int AV_CLASS_CATEGORY_NB = 11;
	};
	/**
	 * <i>native declaration : libavutil/pixfmt.h:315</i><br>
	 * enum values
	 */
	public static interface AVPixelFormat {
		/** <i>native declaration : libavutil/pixfmt.h:1</i> */
		public static final int AV_PIX_FMT_NONE = -1;
		/**
		 * < planar YUV 4:2:0, 12bpp, (1 Cr & Cb sample per 2x2 Y samples)<br>
		 * <i>native declaration : libavutil/pixfmt.h:3</i>
		 */
		public static final int AV_PIX_FMT_YUV420P = 0;
		/**
		 * < packed YUV 4:2:2, 16bpp, Y0 Cb Y1 Cr<br>
		 * <i>native declaration : libavutil/pixfmt.h:5</i>
		 */
		public static final int AV_PIX_FMT_YUYV422 = 1;
		/**
		 * < packed RGB 8:8:8, 24bpp, RGBRGB...<br>
		 * <i>native declaration : libavutil/pixfmt.h:7</i>
		 */
		public static final int AV_PIX_FMT_RGB24 = 2;
		/**
		 * < packed RGB 8:8:8, 24bpp, BGRBGR...<br>
		 * <i>native declaration : libavutil/pixfmt.h:9</i>
		 */
		public static final int AV_PIX_FMT_BGR24 = 3;
		/**
		 * < planar YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)<br>
		 * <i>native declaration : libavutil/pixfmt.h:11</i>
		 */
		public static final int AV_PIX_FMT_YUV422P = 4;
		/**
		 * < planar YUV 4:4:4, 24bpp, (1 Cr & Cb sample per 1x1 Y samples)<br>
		 * <i>native declaration : libavutil/pixfmt.h:13</i>
		 */
		public static final int AV_PIX_FMT_YUV444P = 5;
		/**
		 * < planar YUV 4:1:0,  9bpp, (1 Cr & Cb sample per 4x4 Y samples)<br>
		 * <i>native declaration : libavutil/pixfmt.h:15</i>
		 */
		public static final int AV_PIX_FMT_YUV410P = 6;
		/**
		 * < planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples)<br>
		 * <i>native declaration : libavutil/pixfmt.h:17</i>
		 */
		public static final int AV_PIX_FMT_YUV411P = 7;
		/**
		 * <        Y        ,  8bpp<br>
		 * <i>native declaration : libavutil/pixfmt.h:19</i>
		 */
		public static final int AV_PIX_FMT_GRAY8 = 8;
		/**
		 * <        Y        ,  1bpp, 0 is white, 1 is black, in each byte pixels are ordered from the msb to the lsb<br>
		 * <i>native declaration : libavutil/pixfmt.h:21</i>
		 */
		public static final int AV_PIX_FMT_MONOWHITE = 9;
		/**
		 * <        Y        ,  1bpp, 0 is black, 1 is white, in each byte pixels are ordered from the msb to the lsb<br>
		 * <i>native declaration : libavutil/pixfmt.h:23</i>
		 */
		public static final int AV_PIX_FMT_MONOBLACK = 10;
		/**
		 * < 8 bit with PIX_FMT_RGB32 palette<br>
		 * <i>native declaration : libavutil/pixfmt.h:25</i>
		 */
		public static final int AV_PIX_FMT_PAL8 = 11;
		/**
		 * < planar YUV 4:2:0, 12bpp, full scale (JPEG), deprecated in favor of PIX_FMT_YUV420P and setting color_range<br>
		 * <i>native declaration : libavutil/pixfmt.h:27</i>
		 */
		public static final int AV_PIX_FMT_YUVJ420P = 12;
		/**
		 * < planar YUV 4:2:2, 16bpp, full scale (JPEG), deprecated in favor of PIX_FMT_YUV422P and setting color_range<br>
		 * <i>native declaration : libavutil/pixfmt.h:29</i>
		 */
		public static final int AV_PIX_FMT_YUVJ422P = 13;
		/**
		 * < planar YUV 4:4:4, 24bpp, full scale (JPEG), deprecated in favor of PIX_FMT_YUV444P and setting color_range<br>
		 * <i>native declaration : libavutil/pixfmt.h:31</i>
		 */
		public static final int AV_PIX_FMT_YUVJ444P = 14;
		/**
		 * < XVideo Motion Acceleration via common packet passing<br>
		 * <i>native declaration : libavutil/pixfmt.h:33</i>
		 */
		public static final int AV_PIX_FMT_XVMC_MPEG2_MC = 15;
		/** <i>native declaration : libavutil/pixfmt.h:34</i> */
		public static final int AV_PIX_FMT_XVMC_MPEG2_IDCT = 16;
		/**
		 * < packed YUV 4:2:2, 16bpp, Cb Y0 Cr Y1<br>
		 * <i>native declaration : libavutil/pixfmt.h:36</i>
		 */
		public static final int AV_PIX_FMT_UYVY422 = 17;
		/**
		 * < packed YUV 4:1:1, 12bpp, Cb Y0 Y1 Cr Y2 Y3<br>
		 * <i>native declaration : libavutil/pixfmt.h:38</i>
		 */
		public static final int AV_PIX_FMT_UYYVYY411 = 18;
		/**
		 * < packed RGB 3:3:2,  8bpp, (msb)2B 3G 3R(lsb)<br>
		 * <i>native declaration : libavutil/pixfmt.h:40</i>
		 */
		public static final int AV_PIX_FMT_BGR8 = 19;
		/**
		 * < packed RGB 1:2:1 bitstream,  4bpp, (msb)1B 2G 1R(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits<br>
		 * <i>native declaration : libavutil/pixfmt.h:42</i>
		 */
		public static final int AV_PIX_FMT_BGR4 = 20;
		/**
		 * < packed RGB 1:2:1,  8bpp, (msb)1B 2G 1R(lsb)<br>
		 * <i>native declaration : libavutil/pixfmt.h:44</i>
		 */
		public static final int AV_PIX_FMT_BGR4_BYTE = 21;
		/**
		 * < packed RGB 3:3:2,  8bpp, (msb)2R 3G 3B(lsb)<br>
		 * <i>native declaration : libavutil/pixfmt.h:46</i>
		 */
		public static final int AV_PIX_FMT_RGB8 = 22;
		/**
		 * < packed RGB 1:2:1 bitstream,  4bpp, (msb)1R 2G 1B(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits<br>
		 * <i>native declaration : libavutil/pixfmt.h:48</i>
		 */
		public static final int AV_PIX_FMT_RGB4 = 23;
		/**
		 * < packed RGB 1:2:1,  8bpp, (msb)1R 2G 1B(lsb)<br>
		 * <i>native declaration : libavutil/pixfmt.h:50</i>
		 */
		public static final int AV_PIX_FMT_RGB4_BYTE = 24;
		/**
		 * < planar YUV 4:2:0, 12bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)<br>
		 * <i>native declaration : libavutil/pixfmt.h:52</i>
		 */
		public static final int AV_PIX_FMT_NV12 = 25;
		/**
		 * < as above, but U and V bytes are swapped<br>
		 * <i>native declaration : libavutil/pixfmt.h:54</i>
		 */
		public static final int AV_PIX_FMT_NV21 = 26;
		/**
		 * < packed ARGB 8:8:8:8, 32bpp, ARGBARGB...<br>
		 * <i>native declaration : libavutil/pixfmt.h:56</i>
		 */
		public static final int AV_PIX_FMT_ARGB = 27;
		/**
		 * < packed RGBA 8:8:8:8, 32bpp, RGBARGBA...<br>
		 * <i>native declaration : libavutil/pixfmt.h:58</i>
		 */
		public static final int AV_PIX_FMT_RGBA = 28;
		/**
		 * < packed ABGR 8:8:8:8, 32bpp, ABGRABGR...<br>
		 * <i>native declaration : libavutil/pixfmt.h:60</i>
		 */
		public static final int AV_PIX_FMT_ABGR = 29;
		/**
		 * < packed BGRA 8:8:8:8, 32bpp, BGRABGRA...<br>
		 * <i>native declaration : libavutil/pixfmt.h:62</i>
		 */
		public static final int AV_PIX_FMT_BGRA = 30;
		/**
		 * <        Y        , 16bpp, big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:64</i>
		 */
		public static final int AV_PIX_FMT_GRAY16BE = 31;
		/**
		 * <        Y        , 16bpp, little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:66</i>
		 */
		public static final int AV_PIX_FMT_GRAY16LE = 32;
		/**
		 * < planar YUV 4:4:0 (1 Cr & Cb sample per 1x2 Y samples)<br>
		 * <i>native declaration : libavutil/pixfmt.h:68</i>
		 */
		public static final int AV_PIX_FMT_YUV440P = 33;
		/**
		 * < planar YUV 4:4:0 full scale (JPEG), deprecated in favor of PIX_FMT_YUV440P and setting color_range<br>
		 * <i>native declaration : libavutil/pixfmt.h:70</i>
		 */
		public static final int AV_PIX_FMT_YUVJ440P = 34;
		/**
		 * < planar YUV 4:2:0, 20bpp, (1 Cr & Cb sample per 2x2 Y & A samples)<br>
		 * <i>native declaration : libavutil/pixfmt.h:72</i>
		 */
		public static final int AV_PIX_FMT_YUVA420P = 35;
		/**
		 * < packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:74</i>
		 */
		public static final int AV_PIX_FMT_RGB48BE = 36;
		/**
		 * < packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:76</i>
		 */
		public static final int AV_PIX_FMT_RGB48LE = 37;
		/**
		 * < packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:78</i>
		 */
		public static final int AV_PIX_FMT_RGB565BE = 38;
		/**
		 * < packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:80</i>
		 */
		public static final int AV_PIX_FMT_RGB565LE = 39;
		/**
		 * < packed RGB 5:5:5, 16bpp, (msb)1A 5R 5G 5B(lsb), big-endian, most significant bit to 0<br>
		 * <i>native declaration : libavutil/pixfmt.h:82</i>
		 */
		public static final int AV_PIX_FMT_RGB555BE = 40;
		/**
		 * < packed RGB 5:5:5, 16bpp, (msb)1A 5R 5G 5B(lsb), little-endian, most significant bit to 0<br>
		 * <i>native declaration : libavutil/pixfmt.h:84</i>
		 */
		public static final int AV_PIX_FMT_RGB555LE = 41;
		/**
		 * < packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:86</i>
		 */
		public static final int AV_PIX_FMT_BGR565BE = 42;
		/**
		 * < packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:88</i>
		 */
		public static final int AV_PIX_FMT_BGR565LE = 43;
		/**
		 * < packed BGR 5:5:5, 16bpp, (msb)1A 5B 5G 5R(lsb), big-endian, most significant bit to 1<br>
		 * <i>native declaration : libavutil/pixfmt.h:90</i>
		 */
		public static final int AV_PIX_FMT_BGR555BE = 44;
		/**
		 * < packed BGR 5:5:5, 16bpp, (msb)1A 5B 5G 5R(lsb), little-endian, most significant bit to 1<br>
		 * <i>native declaration : libavutil/pixfmt.h:92</i>
		 */
		public static final int AV_PIX_FMT_BGR555LE = 45;
		/**
		 * < HW acceleration through VA API at motion compensation entry-point, Picture.data[3] contains a vaapi_render_state struct which contains macroblocks as well as various fields extracted from headers<br>
		 * <i>native declaration : libavutil/pixfmt.h:94</i>
		 */
		public static final int AV_PIX_FMT_VAAPI_MOCO = 46;
		/**
		 * < HW acceleration through VA API at IDCT entry-point, Picture.data[3] contains a vaapi_render_state struct which contains fields extracted from headers<br>
		 * <i>native declaration : libavutil/pixfmt.h:96</i>
		 */
		public static final int AV_PIX_FMT_VAAPI_IDCT = 47;
		/**
		 * < HW decoding through VA API, Picture.data[3] contains a vaapi_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers<br>
		 * <i>native declaration : libavutil/pixfmt.h:98</i>
		 */
		public static final int AV_PIX_FMT_VAAPI_VLD = 48;
		/**
		 * < planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:100</i>
		 */
		public static final int AV_PIX_FMT_YUV420P16LE = 49;
		/**
		 * < planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:102</i>
		 */
		public static final int AV_PIX_FMT_YUV420P16BE = 50;
		/**
		 * < planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:104</i>
		 */
		public static final int AV_PIX_FMT_YUV422P16LE = 51;
		/**
		 * < planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:106</i>
		 */
		public static final int AV_PIX_FMT_YUV422P16BE = 52;
		/**
		 * < planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:108</i>
		 */
		public static final int AV_PIX_FMT_YUV444P16LE = 53;
		/**
		 * < planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:110</i>
		 */
		public static final int AV_PIX_FMT_YUV444P16BE = 54;
		/**
		 * < HW decoding through DXVA2, Picture.data[3] contains a LPDIRECT3DSURFACE9 pointer<br>
		 * <i>native declaration : libavutil/pixfmt.h:112</i>
		 */
		public static final int AV_PIX_FMT_DXVA2_VLD = 55;
		/**
		 * < packed RGB 4:4:4, 16bpp, (msb)4A 4R 4G 4B(lsb), little-endian, most significant bits to 0<br>
		 * <i>native declaration : libavutil/pixfmt.h:114</i>
		 */
		public static final int AV_PIX_FMT_RGB444LE = 56;
		/**
		 * < packed RGB 4:4:4, 16bpp, (msb)4A 4R 4G 4B(lsb), big-endian, most significant bits to 0<br>
		 * <i>native declaration : libavutil/pixfmt.h:116</i>
		 */
		public static final int AV_PIX_FMT_RGB444BE = 57;
		/**
		 * < packed BGR 4:4:4, 16bpp, (msb)4A 4B 4G 4R(lsb), little-endian, most significant bits to 1<br>
		 * <i>native declaration : libavutil/pixfmt.h:118</i>
		 */
		public static final int AV_PIX_FMT_BGR444LE = 58;
		/**
		 * < packed BGR 4:4:4, 16bpp, (msb)4A 4B 4G 4R(lsb), big-endian, most significant bits to 1<br>
		 * <i>native declaration : libavutil/pixfmt.h:120</i>
		 */
		public static final int AV_PIX_FMT_BGR444BE = 59;
		/**
		 * < 8bit gray, 8bit alpha<br>
		 * <i>native declaration : libavutil/pixfmt.h:122</i>
		 */
		public static final int AV_PIX_FMT_GRAY8A = 60;
		/**
		 * < packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:124</i>
		 */
		public static final int AV_PIX_FMT_BGR48BE = 61;
		/**
		 * < packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:126</i>
		 */
		public static final int AV_PIX_FMT_BGR48LE = 62;
		/**
		 * The following 12 formats have the disadvantage of needing 1 format for each bit depth.<br>
		 * Notice that each 9/10 bits sample is stored in 16 bits with extra padding.<br>
		 * If you want to support multiple bit depths, then using AV_PIX_FMT_YUV420P16* with the bpp stored separately is better.<br>
		 * < planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:133</i>
		 */
		public static final int AV_PIX_FMT_YUV420P9BE = 63;
		/**
		 * < planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:135</i>
		 */
		public static final int AV_PIX_FMT_YUV420P9LE = 64;
		/**
		 * < planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:137</i>
		 */
		public static final int AV_PIX_FMT_YUV420P10BE = 65;
		/**
		 * < planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:139</i>
		 */
		public static final int AV_PIX_FMT_YUV420P10LE = 66;
		/**
		 * < planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:141</i>
		 */
		public static final int AV_PIX_FMT_YUV422P10BE = 67;
		/**
		 * < planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:143</i>
		 */
		public static final int AV_PIX_FMT_YUV422P10LE = 68;
		/**
		 * < planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:145</i>
		 */
		public static final int AV_PIX_FMT_YUV444P9BE = 69;
		/**
		 * < planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:147</i>
		 */
		public static final int AV_PIX_FMT_YUV444P9LE = 70;
		/**
		 * < planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:149</i>
		 */
		public static final int AV_PIX_FMT_YUV444P10BE = 71;
		/**
		 * < planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:151</i>
		 */
		public static final int AV_PIX_FMT_YUV444P10LE = 72;
		/**
		 * < planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:153</i>
		 */
		public static final int AV_PIX_FMT_YUV422P9BE = 73;
		/**
		 * < planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:155</i>
		 */
		public static final int AV_PIX_FMT_YUV422P9LE = 74;
		/**
		 * < hardware decoding through VDA<br>
		 * <i>native declaration : libavutil/pixfmt.h:157</i>
		 */
		public static final int AV_PIX_FMT_VDA_VLD = 75;
		/**
		 * < planar GBR 4:4:4 24bpp<br>
		 * <i>native declaration : libavutil/pixfmt.h:159</i>
		 */
		public static final int AV_PIX_FMT_GBRP = 76;
		/**
		 * < planar GBR 4:4:4 27bpp, big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:161</i>
		 */
		public static final int AV_PIX_FMT_GBRP9BE = 77;
		/**
		 * < planar GBR 4:4:4 27bpp, little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:163</i>
		 */
		public static final int AV_PIX_FMT_GBRP9LE = 78;
		/**
		 * < planar GBR 4:4:4 30bpp, big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:165</i>
		 */
		public static final int AV_PIX_FMT_GBRP10BE = 79;
		/**
		 * < planar GBR 4:4:4 30bpp, little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:167</i>
		 */
		public static final int AV_PIX_FMT_GBRP10LE = 80;
		/**
		 * < planar GBR 4:4:4 48bpp, big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:169</i>
		 */
		public static final int AV_PIX_FMT_GBRP16BE = 81;
		/**
		 * < planar GBR 4:4:4 48bpp, little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:171</i>
		 */
		public static final int AV_PIX_FMT_GBRP16LE = 82;
		/**
		 * duplicated pixel formats for compatibility with libav.<br>
		 * FFmpeg supports these formats since May 8 2012 and Jan 28 2012 (commits f9ca1ac7 and 143a5c55)<br>
		 * Libav added them Oct 12 2012 with incompatible values (commit 6d5600e85)<br>
		 * < planar YUV 4:2:2 24bpp, (1 Cr & Cb sample per 2x1 Y & A samples)<br>
		 * <i>native declaration : libavutil/pixfmt.h:178</i>
		 */
		public static final int AV_PIX_FMT_YUVA422P_LIBAV = 83;
		/**
		 * < planar YUV 4:4:4 32bpp, (1 Cr & Cb sample per 1x1 Y & A samples)<br>
		 * <i>native declaration : libavutil/pixfmt.h:180</i>
		 */
		public static final int AV_PIX_FMT_YUVA444P_LIBAV = 84;
		/**
		 * < planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:182</i>
		 */
		public static final int AV_PIX_FMT_YUVA420P9BE = 85;
		/**
		 * < planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:184</i>
		 */
		public static final int AV_PIX_FMT_YUVA420P9LE = 86;
		/**
		 * < planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:186</i>
		 */
		public static final int AV_PIX_FMT_YUVA422P9BE = 87;
		/**
		 * < planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:188</i>
		 */
		public static final int AV_PIX_FMT_YUVA422P9LE = 88;
		/**
		 * < planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:190</i>
		 */
		public static final int AV_PIX_FMT_YUVA444P9BE = 89;
		/**
		 * < planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:192</i>
		 */
		public static final int AV_PIX_FMT_YUVA444P9LE = 90;
		/**
		 * < planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian)<br>
		 * <i>native declaration : libavutil/pixfmt.h:194</i>
		 */
		public static final int AV_PIX_FMT_YUVA420P10BE = 91;
		/**
		 * < planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian)<br>
		 * <i>native declaration : libavutil/pixfmt.h:196</i>
		 */
		public static final int AV_PIX_FMT_YUVA420P10LE = 92;
		/**
		 * < planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian)<br>
		 * <i>native declaration : libavutil/pixfmt.h:198</i>
		 */
		public static final int AV_PIX_FMT_YUVA422P10BE = 93;
		/**
		 * < planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian)<br>
		 * <i>native declaration : libavutil/pixfmt.h:200</i>
		 */
		public static final int AV_PIX_FMT_YUVA422P10LE = 94;
		/**
		 * < planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian)<br>
		 * <i>native declaration : libavutil/pixfmt.h:202</i>
		 */
		public static final int AV_PIX_FMT_YUVA444P10BE = 95;
		/**
		 * < planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian)<br>
		 * <i>native declaration : libavutil/pixfmt.h:204</i>
		 */
		public static final int AV_PIX_FMT_YUVA444P10LE = 96;
		/**
		 * < planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian)<br>
		 * <i>native declaration : libavutil/pixfmt.h:206</i>
		 */
		public static final int AV_PIX_FMT_YUVA420P16BE = 97;
		/**
		 * < planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian)<br>
		 * <i>native declaration : libavutil/pixfmt.h:208</i>
		 */
		public static final int AV_PIX_FMT_YUVA420P16LE = 98;
		/**
		 * < planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian)<br>
		 * <i>native declaration : libavutil/pixfmt.h:210</i>
		 */
		public static final int AV_PIX_FMT_YUVA422P16BE = 99;
		/**
		 * < planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian)<br>
		 * <i>native declaration : libavutil/pixfmt.h:212</i>
		 */
		public static final int AV_PIX_FMT_YUVA422P16LE = 100;
		/**
		 * < planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian)<br>
		 * <i>native declaration : libavutil/pixfmt.h:214</i>
		 */
		public static final int AV_PIX_FMT_YUVA444P16BE = 101;
		/**
		 * < planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian)<br>
		 * <i>native declaration : libavutil/pixfmt.h:216</i>
		 */
		public static final int AV_PIX_FMT_YUVA444P16LE = 102;
		/**
		 * < HW acceleration through VDPAU, Picture.data[3] contains a VdpVideoSurface<br>
		 * <i>native declaration : libavutil/pixfmt.h:218</i>
		 */
		public static final int AV_PIX_FMT_VDPAU = 103;
		/**
		 * < packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as little-endian, the 4 lower bits are set to 0<br>
		 * <i>native declaration : libavutil/pixfmt.h:220</i>
		 */
		public static final int AV_PIX_FMT_XYZ12LE = 104;
		/**
		 * < packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as big-endian, the 4 lower bits are set to 0<br>
		 * <i>native declaration : libavutil/pixfmt.h:222</i>
		 */
		public static final int AV_PIX_FMT_XYZ12BE = 105;
		/**
		 * < interleaved chroma YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)<br>
		 * <i>native declaration : libavutil/pixfmt.h:224</i>
		 */
		public static final int AV_PIX_FMT_NV16 = 106;
		/**
		 * < interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:226</i>
		 */
		public static final int AV_PIX_FMT_NV20LE = 107;
		/**
		 * < interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:228</i>
		 */
		public static final int AV_PIX_FMT_NV20BE = 108;
		/**
		 * < packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:230</i>
		 */
		public static final int AV_PIX_FMT_RGBA64BE = 0x123;
		/**
		 * < packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:232</i>
		 */
		public static final int AV_PIX_FMT_RGBA64LE = (0x123 + 1);
		/**
		 * < packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:234</i>
		 */
		public static final int AV_PIX_FMT_BGRA64BE = (0x123 + 2);
		/**
		 * < packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:236</i>
		 */
		public static final int AV_PIX_FMT_BGRA64LE = (0x123 + 3);
		/**
		 * < packed RGB 8:8:8, 32bpp, 0RGB0RGB...<br>
		 * <i>native declaration : libavutil/pixfmt.h:238</i>
		 */
		public static final int AV_PIX_FMT_0RGB = 0x123 + 4;
		/**
		 * < packed RGB 8:8:8, 32bpp, RGB0RGB0...<br>
		 * <i>native declaration : libavutil/pixfmt.h:240</i>
		 */
		public static final int AV_PIX_FMT_RGB0 = (0x123 + 4 + 1);
		/**
		 * < packed BGR 8:8:8, 32bpp, 0BGR0BGR...<br>
		 * <i>native declaration : libavutil/pixfmt.h:242</i>
		 */
		public static final int AV_PIX_FMT_0BGR = (0x123 + 4 + 2);
		/**
		 * < packed BGR 8:8:8, 32bpp, BGR0BGR0...<br>
		 * <i>native declaration : libavutil/pixfmt.h:244</i>
		 */
		public static final int AV_PIX_FMT_BGR0 = (0x123 + 4 + 3);
		/**
		 * < planar YUV 4:4:4 32bpp, (1 Cr & Cb sample per 1x1 Y & A samples)<br>
		 * <i>native declaration : libavutil/pixfmt.h:246</i>
		 */
		public static final int AV_PIX_FMT_YUVA444P = (0x123 + 4 + 4);
		/**
		 * < planar YUV 4:2:2 24bpp, (1 Cr & Cb sample per 2x1 Y & A samples)<br>
		 * <i>native declaration : libavutil/pixfmt.h:248</i>
		 */
		public static final int AV_PIX_FMT_YUVA422P = (0x123 + 4 + 5);
		/**
		 * < planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:250</i>
		 */
		public static final int AV_PIX_FMT_YUV420P12BE = (0x123 + 4 + 6);
		/**
		 * < planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:252</i>
		 */
		public static final int AV_PIX_FMT_YUV420P12LE = (0x123 + 4 + 7);
		/**
		 * < planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:254</i>
		 */
		public static final int AV_PIX_FMT_YUV420P14BE = (0x123 + 4 + 8);
		/**
		 * < planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:256</i>
		 */
		public static final int AV_PIX_FMT_YUV420P14LE = (0x123 + 4 + 9);
		/**
		 * < planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:258</i>
		 */
		public static final int AV_PIX_FMT_YUV422P12BE = (0x123 + 4 + 10);
		/**
		 * < planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:260</i>
		 */
		public static final int AV_PIX_FMT_YUV422P12LE = (0x123 + 4 + 11);
		/**
		 * < planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:262</i>
		 */
		public static final int AV_PIX_FMT_YUV422P14BE = (0x123 + 4 + 12);
		/**
		 * < planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:264</i>
		 */
		public static final int AV_PIX_FMT_YUV422P14LE = (0x123 + 4 + 13);
		/**
		 * < planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:266</i>
		 */
		public static final int AV_PIX_FMT_YUV444P12BE = (0x123 + 4 + 14);
		/**
		 * < planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:268</i>
		 */
		public static final int AV_PIX_FMT_YUV444P12LE = (0x123 + 4 + 15);
		/**
		 * < planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:270</i>
		 */
		public static final int AV_PIX_FMT_YUV444P14BE = (0x123 + 4 + 16);
		/**
		 * < planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:272</i>
		 */
		public static final int AV_PIX_FMT_YUV444P14LE = (0x123 + 4 + 17);
		/**
		 * < planar GBR 4:4:4 36bpp, big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:274</i>
		 */
		public static final int AV_PIX_FMT_GBRP12BE = (0x123 + 4 + 18);
		/**
		 * < planar GBR 4:4:4 36bpp, little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:276</i>
		 */
		public static final int AV_PIX_FMT_GBRP12LE = (0x123 + 4 + 19);
		/**
		 * < planar GBR 4:4:4 42bpp, big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:278</i>
		 */
		public static final int AV_PIX_FMT_GBRP14BE = (0x123 + 4 + 20);
		/**
		 * < planar GBR 4:4:4 42bpp, little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:280</i>
		 */
		public static final int AV_PIX_FMT_GBRP14LE = (0x123 + 4 + 21);
		/**
		 * < planar GBRA 4:4:4:4 32bpp<br>
		 * <i>native declaration : libavutil/pixfmt.h:282</i>
		 */
		public static final int AV_PIX_FMT_GBRAP = (0x123 + 4 + 22);
		/**
		 * < planar GBRA 4:4:4:4 64bpp, big-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:284</i>
		 */
		public static final int AV_PIX_FMT_GBRAP16BE = (0x123 + 4 + 23);
		/**
		 * < planar GBRA 4:4:4:4 64bpp, little-endian<br>
		 * <i>native declaration : libavutil/pixfmt.h:286</i>
		 */
		public static final int AV_PIX_FMT_GBRAP16LE = (0x123 + 4 + 24);
		/**
		 * < planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples) full scale (JPEG), deprecated in favor of PIX_FMT_YUV411P and setting color_range<br>
		 * <i>native declaration : libavutil/pixfmt.h:288</i>
		 */
		public static final int AV_PIX_FMT_YUVJ411P = (0x123 + 4 + 25);
		/**
		 * < bayer, BGBG..(odd line), GRGR..(even line), 8-bit samples * /<br>
		 * <i>native declaration : libavutil/pixfmt.h:290</i>
		 */
		public static final int AV_PIX_FMT_BAYER_BGGR8 = (0x123 + 4 + 26);
		/**
		 * < bayer, RGRG..(odd line), GBGB..(even line), 8-bit samples * /<br>
		 * <i>native declaration : libavutil/pixfmt.h:292</i>
		 */
		public static final int AV_PIX_FMT_BAYER_RGGB8 = (0x123 + 4 + 27);
		/**
		 * < bayer, GBGB..(odd line), RGRG..(even line), 8-bit samples * /<br>
		 * <i>native declaration : libavutil/pixfmt.h:294</i>
		 */
		public static final int AV_PIX_FMT_BAYER_GBRG8 = (0x123 + 4 + 28);
		/**
		 * < bayer, GRGR..(odd line), BGBG..(even line), 8-bit samples * /<br>
		 * <i>native declaration : libavutil/pixfmt.h:296</i>
		 */
		public static final int AV_PIX_FMT_BAYER_GRBG8 = (0x123 + 4 + 29);
		/**
		 * < bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, little-endian * /<br>
		 * <i>native declaration : libavutil/pixfmt.h:298</i>
		 */
		public static final int AV_PIX_FMT_BAYER_BGGR16LE = (0x123 + 4 + 30);
		/**
		 * < bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, big-endian * /<br>
		 * <i>native declaration : libavutil/pixfmt.h:300</i>
		 */
		public static final int AV_PIX_FMT_BAYER_BGGR16BE = (0x123 + 4 + 31);
		/**
		 * < bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, little-endian * /<br>
		 * <i>native declaration : libavutil/pixfmt.h:302</i>
		 */
		public static final int AV_PIX_FMT_BAYER_RGGB16LE = (0x123 + 4 + 32);
		/**
		 * < bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, big-endian * /<br>
		 * <i>native declaration : libavutil/pixfmt.h:304</i>
		 */
		public static final int AV_PIX_FMT_BAYER_RGGB16BE = (0x123 + 4 + 33);
		/**
		 * < bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, little-endian * /<br>
		 * <i>native declaration : libavutil/pixfmt.h:306</i>
		 */
		public static final int AV_PIX_FMT_BAYER_GBRG16LE = (0x123 + 4 + 34);
		/**
		 * < bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, big-endian * /<br>
		 * <i>native declaration : libavutil/pixfmt.h:308</i>
		 */
		public static final int AV_PIX_FMT_BAYER_GBRG16BE = (0x123 + 4 + 35);
		/**
		 * < bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, little-endian * /<br>
		 * <i>native declaration : libavutil/pixfmt.h:310</i>
		 */
		public static final int AV_PIX_FMT_BAYER_GRBG16LE = (0x123 + 4 + 36);
		/**
		 * < bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, big-endian * /<br>
		 * <i>native declaration : libavutil/pixfmt.h:312</i>
		 */
		public static final int AV_PIX_FMT_BAYER_GRBG16BE = (0x123 + 4 + 37);
		/**
		 * < number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions<br>
		 * <i>native declaration : libavutil/pixfmt.h:314</i>
		 */
		public static final int AV_PIX_FMT_NB = (0x123 + 4 + 38);
	};
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_CONTEXT_SIZE = (boolean)(52 < 54);
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_OLD_AVOPTIONS = (boolean)(52 < 54);
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_SAMPLES_UTILS_RETURN_ZERO = (boolean)(52 < 54);
	/** <i>native declaration : libavutil/dict.h</i> */
	public static final int AV_DICT_IGNORE_SUFFIX = (int)2;
	/** <i>native declaration : libavutil/frame.h</i> */
	public static final int FF_DECODE_ERROR_INVALID_BITSTREAM = (int)1;
	/** <i>native declaration : libavutil/dict.h</i> */
	public static final int AV_DICT_APPEND = (int)32;
	/** <i>native declaration : libavutil/frame.h</i> */
	public static final int AV_NUM_DATA_POINTERS = (int)8;
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_CPU_FLAG_MMX2 = (boolean)(52 < 54);
	/** <i>native declaration : libavutil/version.h</i> */
	public static final int LIBAVUTIL_VERSION_MICRO = (int)100;
	/** <i>native declaration : libavutil/frame.h</i> */
	public static final int AV_FRAME_FLAG_CORRUPT = (int)(1 << 0);
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_AUDIOCONVERT = (boolean)(52 < 54);
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_OLD_OPENCL = (boolean)(52 < 54);
	/** <i>native declaration : libavutil/opt.h</i> */
	public static final int AV_OPT_FLAG_DECODING_PARAM = (int)2;
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_XVMC = (boolean)(52 < 54);
	/** <i>native declaration : libavutil/opt.h</i> */
	public static final int AV_OPT_FLAG_READONLY = (int)128;
	/** <i>native declaration : libavutil/dict.h</i> */
	public static final int AV_DICT_DONT_STRDUP_KEY = (int)4;
	/** <i>native declaration : libavutil/opt.h</i> */
	public static final int AV_OPT_FLAG_ENCODING_PARAM = (int)1;
	/** <i>native declaration : libavutil/opt.h</i> */
	public static final int AV_OPT_FLAG_METADATA = (int)4;
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_INTFLOAT = (boolean)(52 < 54);
	/** <i>native declaration : libavutil/opt.h</i> */
	public static final int AV_OPT_FLAG_FILTERING_PARAM = (int)(1 << 16);
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_GET_BITS_PER_SAMPLE_FMT = (boolean)(52 < 54);
	/**
	 * define<br>
	 * Conversion Error : 52.66.<br>
	 * SKIPPED:<br>
	 * <i>native declaration : libavutil/version.h:0</i><br>
	 * 52.66.
	 */
	/** <i>native declaration : libavutil/opt.h</i> */
	public static final int AV_OPT_FLAG_VIDEO_PARAM = (int)16;
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_VDPAU = (boolean)(52 < 54);
	/** <i>native declaration : libavutil/version.h</i> */
	public static final int LIBAVUTIL_VERSION_MAJOR = (int)52;
	/** <i>native declaration : libavutil/version.h</i> */
	public static final int LIBAVUTIL_VERSION_INT = (int)(52 << 16 | 66 << 8 | 100);
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_PIX_FMT = (boolean)(52 < 54);
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_LLS1 = (boolean)(52 < 54);
	/** <i>native declaration : libavutil/opt.h</i> */
	public static final int AV_OPT_FLAG_SUBTITLE_PARAM = (int)32;
	/** <i>native declaration : libavutil/version.h</i> */
	public static final int LIBAVUTIL_BUILD = (int)(52 << 16 | 66 << 8 | 100);
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_GET_CHANNEL_LAYOUT_COMPAT = (boolean)(52 < 54);
	/** <i>native declaration : libavutil/opt.h</i> */
	public static final int AV_OPT_FLAG_AUDIO_PARAM = (int)8;
	/** <i>native declaration : libavutil/frame.h</i> */
	public static final int FF_DECODE_ERROR_MISSING_REFERENCE = (int)2;
	/** <i>native declaration : libavutil/dict.h</i> */
	public static final int AV_DICT_MATCH_CASE = (int)1;
	/** <i>native declaration : libavutil/dict.h</i> */
	public static final int AV_DICT_DONT_OVERWRITE = (int)16;
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_OPT_TYPE_METADATA = (boolean)(52 < 54);
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_LLS_PRIVATE = (boolean)(52 < 54);
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_PIX_FMT_DESC = (boolean)(52 < 54);
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_AV_REVERSE = (boolean)(52 < 54);
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_AVFRAME_LAVC = (boolean)(52 < 54);
	/** <i>native declaration : libavutil/dict.h</i> */
	public static final int AV_DICT_DONT_STRDUP_VAL = (int)8;
	/** <i>native declaration : libavutil/version.h</i> */
	public static final int LIBAVUTIL_VERSION_MINOR = (int)66;
	/** <i>native declaration : libavutil/opt.h</i> */
	public static final int AV_OPT_FLAG_EXPORT = (int)64;
	/** <i>native declaration : libavutil/version.h</i> */
	public static final String LIBAVUTIL_IDENT = (String)"Lavu52.66.100";
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_FIND_OPT = (boolean)(52 < 54);
	/**
	 * Original signature : <code>int avutil_version()</code><br>
	 * <i>native declaration : libavutil/avutil.h:1</i>
	 */
	int avutil_version();
	/**
	 * Original signature : <code>char* av_get_media_type_string(AVMediaType)</code><br>
	 * <i>native declaration : libavutil/avutil.h:15</i>
	 */
	String av_get_media_type_string(int media_type);
	/**
	 * Original signature : <code>void av_dict_copy(AVDictionary**, AVDictionary*, int)</code><br>
	 * <i>native declaration : libavutil/dict.h:8</i><br>
	 * @deprecated use the safer method {@link #av_dict_copy(org.ffmpeg.avutil.AVDictionary.ByReference[], org.ffmpeg.avutil.AVDictionary, int)} instead
	 */
	@Deprecated 
	void av_dict_copy(PointerByReference dst, AVDictionary src, int flags);
	/**
	 * Original signature : <code>void av_dict_copy(AVDictionary**, AVDictionary*, int)</code><br>
	 * <i>native declaration : libavutil/dict.h:8</i>
	 */
	void av_dict_copy(AVDictionary.ByReference dst[], AVDictionary src, int flags);
	/**
	 * Original signature : <code>void av_dict_free(AVDictionary**)</code><br>
	 * <i>native declaration : libavutil/dict.h:10</i><br>
	 * @deprecated use the safer method {@link #av_dict_free(org.ffmpeg.avutil.AVDictionary.ByReference[])} instead
	 */
	@Deprecated 
	void av_dict_free(PointerByReference m);
	/**
	 * Original signature : <code>void av_dict_free(AVDictionary**)</code><br>
	 * <i>native declaration : libavutil/dict.h:10</i>
	 */
	void av_dict_free(AVDictionary.ByReference m[]);
	/**
	 * Original signature : <code>int av_reduce(int*, int*, int64_t, int64_t, int64_t)</code><br>
	 * <i>native declaration : libavutil/rational.h:7</i><br>
	 * @deprecated use the safer methods {@link #av_reduce(java.nio.IntBuffer, java.nio.IntBuffer, long, long, long)} and {@link #av_reduce(com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, long, long, long)} instead
	 */
	@Deprecated 
	int av_reduce(IntByReference dst_num, IntByReference dst_den, long num, long den, long max);
	/**
	 * Original signature : <code>int av_reduce(int*, int*, int64_t, int64_t, int64_t)</code><br>
	 * <i>native declaration : libavutil/rational.h:7</i>
	 */
	int av_reduce(IntBuffer dst_num, IntBuffer dst_den, long num, long den, long max);
	/**
	 * Original signature : <code>char* av_get_sample_fmt_name(AVSampleFormat)</code><br>
	 * <i>native declaration : libavutil/samplefmt.h:26</i>
	 */
	String av_get_sample_fmt_name(int sample_fmt);
	/**
	 * Original signature : <code>int av_sample_fmt_is_planar(AVSampleFormat)</code><br>
	 * <i>native declaration : libavutil/samplefmt.h:28</i>
	 */
	int av_sample_fmt_is_planar(int sample_fmt);
	/**
	 * Original signature : <code>int av_get_bytes_per_sample(AVSampleFormat)</code><br>
	 * <i>native declaration : libavutil/samplefmt.h:30</i>
	 */
	int av_get_bytes_per_sample(int sample_fmt);
	/**
	 * Original signature : <code>AVSampleFormat av_get_sample_fmt(const char*)</code><br>
	 * <i>native declaration : libavutil/samplefmt.h:32</i><br>
	 * @deprecated use the safer methods {@link #av_get_sample_fmt(java.lang.String)} and {@link #av_get_sample_fmt(com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int av_get_sample_fmt(Pointer name);
	/**
	 * Original signature : <code>AVSampleFormat av_get_sample_fmt(const char*)</code><br>
	 * <i>native declaration : libavutil/samplefmt.h:32</i>
	 */
	int av_get_sample_fmt(String name);
	/**
	 * Original signature : <code>AVSampleFormat av_get_packed_sample_fmt(AVSampleFormat)</code><br>
	 * <i>native declaration : libavutil/samplefmt.h:34</i>
	 */
	int av_get_packed_sample_fmt(int sample_fmt);
	/**
	 * Original signature : <code>void av_opt_set_defaults(void*)</code><br>
	 * <i>native declaration : libavutil/opt.h:61</i>
	 */
	void av_opt_set_defaults(Pointer s);
	/**
	 * Original signature : <code>void av_opt_free(void*)</code><br>
	 * <i>native declaration : libavutil/opt.h:63</i>
	 */
	void av_opt_free(Pointer obj);
	/**
	 * Original signature : <code>int av_opt_set_dict(void*, AVDictionary**)</code><br>
	 * <i>native declaration : libavutil/opt.h:65</i><br>
	 * @deprecated use the safer method {@link #av_opt_set_dict(com.sun.jna.Pointer, org.ffmpeg.avutil.AVDictionary.ByReference[])} instead
	 */
	@Deprecated 
	int av_opt_set_dict(Pointer obj, PointerByReference options);
	/**
	 * Original signature : <code>int av_opt_set_dict(void*, AVDictionary**)</code><br>
	 * <i>native declaration : libavutil/opt.h:65</i>
	 */
	int av_opt_set_dict(Pointer obj, AVDictionary.ByReference options[]);
	/**
	 * Original signature : <code>void* av_malloc(size_t)</code><br>
	 * <i>native declaration : libavutil/mem.h:1</i>
	 */
	Pointer av_malloc(NativeLong size);
	/**
	 * Original signature : <code>void av_free(void*)</code><br>
	 * <i>native declaration : libavutil/mem.h:3</i>
	 */
	void av_free(Pointer ptr);
	/**
	 * Original signature : <code>void av_freep(void*)</code><br>
	 * <i>native declaration : libavutil/mem.h:5</i>
	 */
	void av_freep(Pointer ptr);
	/**
	 * Original signature : <code>void av_image_copy(uint8_t*[4], int[4], const uint8_t*[4], const int[4], AVPixelFormat, int, int)</code><br>
	 * <i>native declaration : libavutil/imgutils.h:1</i><br>
	 * @deprecated use the safer methods {@link #av_image_copy(java.nio.ByteBuffer[], java.nio.IntBuffer, byte[], int[], int, int, int)} and {@link #av_image_copy(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, int, int, int)} instead
	 */
	@Deprecated 
	void av_image_copy(PointerByReference dst_data, IntByReference dst_linesizes, PointerByReference src_data, IntByReference src_linesizes, int pix_fmt, int width, int height);
	/**
	 * Original signature : <code>void av_image_copy(uint8_t*[4], int[4], const uint8_t*[4], const int[4], AVPixelFormat, int, int)</code><br>
	 * <i>native declaration : libavutil/imgutils.h:1</i>
	 */
	void av_image_copy(ByteBuffer dst_data[], IntBuffer dst_linesizes, byte src_data[], int src_linesizes[], int pix_fmt, int width, int height);
	/**
	 * Original signature : <code>char* av_get_pix_fmt_name(AVPixelFormat)</code><br>
	 * <i>native declaration : libavutil/pixdesc.h:1</i>
	 */
	String av_get_pix_fmt_name(int pix_fmt);
	public static class AVPanScan extends PointerType {
		public AVPanScan(Pointer address) {
			super(address);
		}
		public AVPanScan() {
			super();
		}
	};
	public static class AVBufferRef extends PointerType {
		public AVBufferRef(Pointer address) {
			super(address);
		}
		public AVBufferRef() {
			super();
		}
	};
}
